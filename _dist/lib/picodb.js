/*! ****************************************************************************
 * PicoDB v1.0.5
 *
 * A tiny in-memory database (MongoDB like) that stores JSON documents.
 * (you can download it from npm or github repositories)
 * Copyright (c) 2023 Mobilabs <contact@mobilabs.fr> (http://www.mobilabs.fr).
 * Released under the MIT license. You may obtain a copy of the License
 * at: http://www.opensource.org/licenses/mit-license.php).
 * Built from ES6Kadoo v1.0.10.
 * ************************************************************************** */
/*! Generated by Kadoo v1.0.7 */
// ESLint declarations
/* global define */
/* eslint no-shadow: ['error', { 'allow': ['root'] }] */
/* eslint strict: ["error", "function"] */
(function(root, factory) {
  'use strict';

  /* istanbul ignore next */
  if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module.
    define([''], factory);
  } else if (typeof exports === 'object') {
    // Node. Does not work with strict CommonJS, but
    // only CommonJS-like environments that support module.exports,
    // like Node.
    /* eslint-disable-next-line no-param-reassign */
    module.exports = factory(root);
  } else {
    // Browser globals.
    /* eslint-disable-next-line no-param-reassign */
    root.PicoDB = factory(root);
  }
}(this, (root) => {
  'use strict';

  /* ***************************************************************************
   *
   * Tree is an object that links all the internal IIFE modules.
   *
   * ************************************************************************ */
  /* eslint-disable */
  let $__TREE = {"src":{"picodb":{},"lib":{"_":{},"plugin":{}},"private":{"count":{},"delete":{},"find":{},"insert":{},"update":{},"geo":{},"query":{},"projection":{}}}};
  $__TREE.extend=function(o,m){var k=Object.keys(m);for(var i=0;i<k.length;i++){o[k[i]]=m[k[i]]}};
  /* - */
  /* eslint-enable */

  /* index: 1, path: 'src/picodb.js', import: [2, 3, 4, 5, 6, 7, 8, 9] */
  (function() {
    /** ************************************************************************
     *
     * A tiny in-memory database (MongoDB like) that stores JSON documents.
     *
     * This is the entry point of the library where is defined the constructor
     * and the attached methods.
     *
     * picodb.js is built upon the Prototypal Instantiation pattern. It
     * returns an object by calling its constructor. It doesn't use the new
     * keyword.
     *
     * Private Functions:
     *  . none,
     *
     *
     * Constructor:
     *  . PicoDB                    creates and returns the PicoDB object,
     *
     *
     * Private Static Methods:
     *  . _setTestMode                returns internal objects for testing purpose,
     *
     *
     * Public Static Methods:
     *  . noConflict                  returns a reference to this PicoDB object,
     *  . plug                        attaches a plugin library,
     *
     *
     * Public Methods:
     *  . whoami                      returns the library name and version,
     *  . insertOne                   inserts a single document,
     *  . insertMany                  inserts an array of documents,
     *  . find                        finds the searched documents,
     *  . toArray                     returns the found documents in an array,
     *  . count                       counts the documents into the db that match,
     *  . updateOne                   updates one document,
     *  . updateMany                  updates many documents,
     *  . deleteOne                   deletes the first (the oldest) doc. that matches,
     *  . deleteMany                  deletes the documents into the db that match,
     *  . addEventListener            registers the specified listener,
     *  . addOneTimeEventListener     registers the specified listener for once,
     *  . removeEventListener         removes the event registered listener,
     *  . on                          alias on addEventListener,
     *  . one                         alias on addOneTimeEventListener,
     *  . off                         alias on removeEventListener,
     *
     *
     *
     * @namespace    -
     * @dependencies none
     * @exports      -
     * @author       -
     * @since        0.0.0
     * @version      -
     * ********************************************************************** */
    /* - */
    /* eslint-disable one-var, semi-style, no-underscore-dangle */


    // -- Vendor Modules


    // -- Local Modules
    const { _ } = $__TREE.src.lib;
    const C = $__TREE.src.private.count;
    const D = $__TREE.src.private.delete;
    const F = $__TREE.src.private.find;
    const I = $__TREE.src.private.insert;
    const U = $__TREE.src.private.update;
    const P = $__TREE.src.lib.plugin;
    const G = $__TREE.src.private.geo;


    // -- Local Constants


    // -- Local Variables
    let methods
      ;


    // -- Public ---------------------------------------------------------------

    /**
     * Returns the PicoDB object.
     * (Prototypal Instantiation Pattern)
     *
     * @constructor ()
     * @public
     * @param {}                -,
     * @returns {Object}        returns the PicoDB object,
     * @since 0.0.0
     */
    const PicoDB = function() {
      const obj = Object.create(methods);
      obj._library = {
        name: 'PicoDB',
        version: '1.0.5',
      };

      // Creates a cursor.
      obj._cursor = F.initCursor();

      // Creates the database container and attaches to it a schema.
      obj._db = I.schema();

      // Creates a messenger object.
      const M = P.get('messenger');
      obj._mess = M ? M() : null;
      return obj;
    };

    // Attaches constants to PicoDB that provide name and version of the lib.
    PicoDB.NAME = 'PicoDB';
    PicoDB.VERSION = '1.0.5';

    // Saves the previous value of the library variable, so that it can be
    // restored later on, if noConflict is used.
    const previousPicoDB = root.PicoDB;


    // -- Private Static Methods -----------------------------------------------

    /**
     * Returns the internal objects for testing purpose.
     * (must not be deleted)
     *
     * @method ()
     * @private
     * @param {}                -,
     * @returns {Object}        returns a list of internal objects,
     * @since 0.0.0
     */
    PicoDB._setTestMode = function() {
      return [G, P, _];
    };


    // -- Public Static Methods ------------------------------------------------

    /**
     * Returns a reference to this PicoDB object.
     * (must not be deleted)
     *
     * Nota:
     * Running PicoDB in noConflict mode, returns the PicoDB variable to
     * its previous owner.
     *
     * @method ()
     * @public
     * @param {}                -,
     * @returns {Object}        returns the PicoDB object,
     * @since 0.0.0
     */
    PicoDB.noConflict = function() {
      /* eslint-disable-next-line no-param-reassign */
      root.PicoDB = previousPicoDB;
      return this;
    };

    /**
     * Attaches a plugin library.
     *
     * @method (arg1)
     * @public
     * @param {Object}          the plugin library,
     * @returns {Boolean}       returns true if it succeeds,
     * @since 0.0.0
     */
    PicoDB.plugin = function(plug) {
      return P.plugin(plug);
    };


    // -- Public Methods -------------------------------------------------------

    methods = {

      /**
       * Returns the library name and version.
       * (must not be deleted)
       *
       * @method ()
       * @public
       * @param {}              -,
       * @returns {Object}      returns the library name and version,
       * @since 0.0.0
       */
      whoami() {
        return this._library;
      },

      /**
       * Inserts a single document into the db.
       *
       * @method (arg1, [arg2], [arg3])
       * @public
       * @param {Object}        the document to insert,
       * @param {Object}        the optional settings,
       * @param {Function}      the function to call at the completion,
       * @returns {Object}      returns a promise,
       * @since 0.0.0
       */
      insertOne(...args) {
        return I.insert(this._db, this._mess, false, ...args);
      },

      /**
       * Inserts an array of documents into the db.
       *
       * @method (arg1, [arg2], [arg3])
       * @public
       * @param {Array}         the documents to insert,
       * @param {Object}        the optional settings,
       * @param {Function}      the function to call at the completion,
       * @returns {Object}      returns a promise,
       * @since 0.0.0
       */
      insertMany(...args) {
        return I.insert(this._db, this._mess, true, ...args);
      },

      /**
       * Finds the searched documents.
       *
       * @method (arg1, arg2)
       * @public
       * @param {Object}        the query object,
       * @param {Object}        the projection object,
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      find(...args) {
        F.find(this._cursor, ...args);
        return this;
      },

      /**
       * Returns the found documents in an array.
       *
       * @method (arg1)
       * @public
       * @param {Object}        the function to call at the completion,
       * @returns {Object}      returns a promise,
       * @since 0.0.0
       */
      toArray(callback) {
        return F.toArray(this._db, this._cursor, callback);
      },

      /**
       * Counts the documents into the db that match.
       *
       * @method (arg1, [arg2], [arg3])
       * @public
       * @param {Object}        the query object,
       * @param {Options}       the optional settings,
       * @param {Function}      the function to call at the completion,
       * @returns {Object}      returns a promise,
       * @since 0.0.0
       */
      count(...args) {
        return C.count(this._db, ...args);
      },

      /**
       * Updates many documents into the db.
       *
       * @method (arg1, arg2, [arg3], [arg4])
       * @public
       * @param {Object}        the query object,
       * @param {object}        the items to update,
       * @param {Object}        the optional settings,
       * @param {Function}      the function to call at the completion,
       * @returns {Object}      returns a promise,
       * @since 0.0.0
       */
      updateOne(...args) {
        return U.update(this._db, this._mess, false, ...args);
      },

      /**
       * Updates many documents into the db.
       *
       * @method (arg1, arg2, arg3, arg4)
       * @public
       * @param {Object}        the query object,
       * @param {object}        the items to update,
       * @param {Object}        the optional settings,
       * @param {Function}      the function to call at the completion,
       * @returns {Object}      returns a promise,
       * @since 0.0.0
       */
      updateMany(...args) {
        return U.update(this._db, this._mess, true, ...args);
      },

      /**
       * Deletes the first (the oldest) document into the db that matches.
       *
       * @method (arg1, [arg2], [arg3])
       * @public
       * @param {Object}        the object to found,
       * @param {Options}       the optional settings,
       * @param {Function}      the function to call at the completion,
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      deleteOne(...args) {
        return D.delete(this._db, this._mess, false, ...args);
      },

      /**
       * Deletes the documents into the db that match.
       *
       * @method (arg1, [arg2], [arg3])
       * @public
       * @param {Object}        the object to found,
       * @param {Options}       the optional settings,
       * @param {Function}      the function to call at the completion,
       * @returns {Object}      returns a promise,
       * @since 0.0.0
       */
      deleteMany(...args) {
        return D.delete(this._db, this._mess, true, ...args);
      },

      /**
       * Registers the specified listener on the event it's called on.
       *
       * @method (arg1, arg2)
       * @public
       * @param {String}        the name of the event,
       * @param {function}      the event listener,
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      addEventListener(ename, listener) {
        if (this._mess) {
          this._mess.subscribe(ename, listener);
          return this;
        }
        /* eslint-disable-next-line no-console */
        console.log('warning: the plugin @mobilabs/messenger isn\'t installed!');
        return this;
      },

      /**
       * Registers the specified listener on the event for once.
       *
       * @method (arg1, arg2)
       * @public
       * @param {String}        the name of the event,
       * @param {function}      the event listener,
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      addOneTimeEventListener(ename, listener) {
        if (this._mess) {
          this._mess.subscribeOnce(ename, listener);
          return this;
        }
        /* eslint-disable-next-line no-console */
        console.log('warning: the plugin @mobilabs/messenger isn\'t installed!');
        return this;
      },

      /**
       * Removes the event listener previously registered with addEventListener.
       *
       * @method (arg1, arg2)
       * @public
       * @param {String}        the name of the event,
       * @param {function}      the event listener,
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      removeEventListener(ename, listener) {
        if (this._mess) {
          this._mess.unsubscribe(ename, listener);
        }
        return this;
      },

      /**
       * Registers the specified listener on the event it's called on.
       *
       * @method (arg1, arg2)
       * @public
       * @param {String}        the name of the event,
       * @param {function}      the event listener,
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      on(ename, listener) {
        return this.addEventListener(ename, listener);
      },

      /**
       * Registers the specified listener on the event for once.
       *
       * @method (arg1, arg2)
       * @public
       * @param {String}        the name of the event,
       * @param {function}      the event listener,
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      one(ename, listener) {
        return this.addOneTimeEventListener(ename, listener);
      },

      /**
       * Removes the event listener previously registered with addEventListener.
       *
       * @method (arg1, arg2)
       * @public
       * @param {String}        the name of the event,
       * @param {function}      the event listener,
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      off(ename, listener) {
        return this.removeEventListener(ename, listener);
      },
    };


    // -- Export
    $__TREE.src.picodb = PicoDB;

    /* eslint-enable one-var, semi-style, no-underscore-dangle */
  }());

  /* index: 2, path: 'src/lib/_.js', import: [] */
  (function() {
    /** ************************************************************************
     *
     * A micro subset of the Overslash library plus some extras.
     *
     * _.js is just a literal object that contains a set of functions.
     * It can't be instantiated.
     *
     * Private Functions:
     *  . _normalize                  normalizes from { 'a.b': 1 } to { a: { b: 1 }},
     *
     *
     * Public Static Methods:
     *  . isUndefined                 is a given variable undefined?,
     *  . isNull                      is a given value null?,
     *  . isBoolean                   is a given value a boolean?
     *  . isString                    is a given value a string?
     *  . isNumber                    is a given value a number?
     *  . isNaN                       is a given value NaN?
     *  . isOdd                       is a given value an odd number?
     *
     *  . isObject                    is a given variable an object?
     *  . isLiteralObject             Is a given variable a literal object?
     *  . isFunction                  is a given variable a function?
     *  . isArray                     is a given value an array?
     *  . isEmpty                     is a given array, string or object empty?
     *
     *  . clone                       clones a literal object or an array,
     *  . extend                      extends a given object with all the properties,
     *  . keys                        retrieves all the names of the object's,
     *  . forPropIn                   parses all the names of the object's,
     *
     *  . contains                    returns true if the array contains the passed-in value,
     *  . share                       returns the list of the elements in common,
     *
     *  . token                       returns a unique string pattern in base 36,
     *
     *  . normalize                   normalizes from { 'a.b': 1 } to { a: { b: 1 }},
     *
     *
     * @namespace    -
     * @dependencies none
     * @exports      -
     * @author       -
     * @since        0.0.0
     * @version      -
     * ********************************************************************** */
    /* - */
    /* eslint-disable one-var, semi-style, no-underscore-dangle */


    // -- Vendor Modules


    // -- Local Modules


    // -- Local Constants


    // -- Local Variables


    // -- Private Functions ----------------------------------------------------

    /**
     * Normalizes an object from { 'a.b': 1 } to { a: { b: 1 }}.
     *
     * @function (arg1)
     * @private
     * @param {Object}          the object,
     * @returns {Object}        returns the normalized object,
     * @since 0.0.0
     */
    function _normalize(obj) {
      const nobj = {};
      Object.keys(obj).forEach((prop) => {
        if (prop.includes('.')) {
          const props = prop.split('.');
          let iobj = nobj;
          for (let i = 0; i < props.length; i++) {
            if (i < (props.length - 1)) {
              iobj[props[i]] = {};
              iobj = iobj[props[i]];
            } else if (Object.prototype.toString.call(obj[prop]) === '[object Object]') {
              iobj[props[i]] = _normalize(obj[prop]);
            } else {
              iobj[props[i]] = obj[prop];
            }
          }
        } else if (Object.prototype.toString.call(obj[prop]) === '[object Object]') {
          nobj[prop] = _normalize(obj[prop]);
        } else {
          nobj[prop] = obj[prop];
        }
      });
      return nobj;
    }


    // -- Public Static Methods ------------------------------------------------

    /* istanbul ignore next */
    // This is just a copy paste of portions of the library '@mobilabs/overslash'.
    // So, there is no need to test it.
    const _ = {

      // --- Primitives types --------------------------------------------------

      /**
       * Is a given variable undefined?
       *
       * @method (arg1)
       * @public
       * @param {Object}        the object to test,
       * @returns {Boolean}     returns true or false,
       * @since 0.0.0
       */
      isUndefined(obj) {
        return obj === undefined;
      },

      /**
       * Is a given value null?
       *
       * @method (arg1)
       * @public
       * @param {Object}        the object to test,
       * @returns {Boolean}     returns true or false,
       * @since 0.0.0
       */
      isNull(obj) {
        return obj === null;
      },

      /**
       * Is a given value a boolean?
       *
       * @method (arg1)
       * @public
       * @param {Object}        the object to test,
       * @returns {Boolean}     returns true or false,
       * @since 0.0.0
       */
      isBoolean(obj) {
        return obj === true || obj === false || Object.prototype.toString.call(obj) === '[object Boolean]';
      },

      /**
       * Is a given value a string?
       *
       * @method (arg1)
       * @public
       * @param {Object}        the object to test,
       * @returns {Boolean}     returns true or false,
       * @since 0.0.0
       */
      isString(obj) {
        return Object.prototype.toString.call(obj) === '[object String]';
      },

      /**
       * Is a given value a number?
       *
       * @method (arg1)
       * @public
       * @param {Object}        the object to test,
       * @returns {Boolean}     returns true or false,
       * @since 0.0.0
       */
      isNumber(obj) {
        return Object.prototype.toString.call(obj) === '[object Number]';
      },

      /**
       * Is a given value NaN?
       * (NaN is the only number which does not equal itself)
       * (copied from: http://underscorejs.org)
       *
       * @method (arg1)
       * @public
       * @param {Object}        the object to test,
       * @returns {Boolean}     returns true or false,
       * @since 0.0.0
       */
      isNaN(obj) {
        return this.isNumber(obj) && obj !== +obj;
      },

      /**
       * Is a given value an odd number?
       *
       * @method (arg1)
       * @public
       * @param {Object}        the object to test,
       * @returns {Boolean}     returns true (odd), false (even) or undefined (not a number),
       * @since 0.0.0
       */
      /* eslint-disable no-void */
      isOdd(obj) {
        const n = obj % 2;
        return obj === parseFloat(obj) ? !!n : void 0;
      },
      /* eslint-enable no-void */


      // --- Object types ------------------------------------------------------

      /**
       * Is a given variable an object?
       * (copied from: http://underscorejs.org)
       *
       * @method (arg1)
       * @public
       * @param {Object}        the object to test,
       * @returns {Boolean}     returns true or false,
       * @since 0.0.0
       */
      isObject(obj) {
        const type = typeof obj;
        return (type === 'function' || type === 'object') && !!obj;
      },

      /**
       * Is a given variable a literal object?
       *
       * @method (arg1)
       * @private
       * @param {Object}        the object to test,
       * @returns {Boolean}     returns true or false,
       * @since 0.0.3
       */
      isLiteralObject(obj) {
        return Object.prototype.toString.call(obj) === '[object Object]';
      },

      /**
       * Is a given variable a function?
       *
       * @method (arg1)
       * @public
       * @param {Object}        the object to test,
       * @returns {Boolean}     returns true or false,
       * @since 0.0.0
       */
      isFunction(obj) {
        return Object.prototype.toString.call(obj) === '[object Function]';
      },

      /**
       * Is a given value an array?
       * (Delegates to ECMA5's native Array.isArray.)
       * (copied from: http://underscorejs.org)
       *
       * @method (arg1)
       * @public
       * @param {Object}        the object to test,
       * @returns {Boolean}     returns true or false,
       * @since 0.0.0
       */
      /* istanbul ignore next */
      isArray(obj) {
        return Object.prototype.toString.call(obj) === '[object Array]';
      },

      /**
       * Is a given array, string or object empty?
       *
       * @method (arg1)
       * @public
       * @param {Object}        the object to test,
       * @returns {Boolean}     returns true or false,
       * @since 0.0.0
       */
      /* eslint-disable no-restricted-syntax, no-prototype-builtins */
      isEmpty(obj) {
        let key;
        if (obj === null) return true;
        if (this.isArray(obj) || this.isString(obj)) return obj.length === 0;
        // Check that the object has no enumerable own-properties.
        // If ECMAScript 5 support only: 'return Object.keys(obj).length === 0;'
        // Otherwise, parse all properties.
        for (key in obj) if (obj.hasOwnProperty(key)) return false;
        return true;
      },
      /* eslint-enable no-restricted-syntax, no-prototype-builtins */


      // --- Operations on Objects ---------------------------------------------

      /**
       * Clones a literal object or an array.
       *
       * @method (arg1)
       * @public
       * @param {Object}        the object to clone,
       * @returns {Object}      returns the cloned object,
       * @since 0.0.0
       */
      /* eslint-disable no-void, no-restricted-syntax */
      clone(obj) {
        const clone = this.isArray(obj) ? [] : {};
        let prop;

        if (!this.isObject(obj)) return void 0;

        for (prop in obj) {
          if (this.isArray(obj[prop])) {
            clone[prop] = this.clone(obj[prop]);
          } else if (this.isObject(obj[prop])) {
            clone[prop] = this.extend(obj[prop]);
          } else {
            clone[prop] = obj[prop];
          }
        }
        return clone;
      },
      /* eslint-enable no-void, no-restricted-syntax */

      /**
       * Extends a given object with all the properties in passed-in object(s).
       * (copied from: http://underscorejs.org and added recursivity)
       *
       * @method (arg1)
       * @public
       * @param {Object}        the objects to merge,
       * @returns {Object}      the resulting object,
       * @since 0.0.0
       */
      /* eslint-disable no-restricted-syntax, no-param-reassign, prefer-rest-params */
      extend(obj) {
        let source
          , prop
          ;

        if (!this.isObject(obj)) return obj;

        for (let i = 1; i < arguments.length; i++) {
          source = arguments[i];
          for (prop in source) {
            // if (!this.isArray(arguments[i][prop]) && this.isObject(arguments[i][prop])) {
            if (this.isLiteralObject(arguments[i][prop])) {
              obj[prop] = obj[prop] !== undefined ? obj[prop] : {};
              this.extend(obj[prop], arguments[i][prop]);
            } /* istanbul ignore next */ else if (hasOwnProperty.call(source, prop)) {
              obj[prop] = this.isArray(source[prop])
                ? this.clone(source[prop])
                : source[prop];
            }
          }
        }
        return obj;
      },
      /* eslint-enable no-restricted-syntax, no-param-reassign, prefer-rest-params */

      /**
       * Retrieves all the names of the object's own enumerable properties.
       * (ECMAScript 5 only).
       *
       * @method (arg1)
       * @public
       * @param {Object}      the input object,
       * @returns {Array}     returns the names of the keys,
       * @since 0.0.0
       */
      keys(obj) {
        return Object.keys(obj);
      },

      /**
       * Parses all the names of the object's own enumerable properties.
       * (replace for...in statement).
       * (ECMAScript 5 only).
       *
       * @method (arg1, arg2)
       * @public
       * @param {Object}      the input object,
       * @returns {Array}     returns the names of the keys,
       * @since 0.0.0
       */
      forPropIn(obj, callback) {
        // var keys = overslash.keys(obj);
        this.keys(obj).forEach((key) => {
          /* istanbul ignore next */
          if ({}.hasOwnProperty.call(obj, key)) {
            callback(key);
          }
        });
      },


      // -- Operations on Arrays -----------------------------------------------

      /**
       * Returns true if the array contains the passed-in value.
       *
       * Note:
       * The array must be a first-level only array.
       *
       * @method(arg1, arg2)
       * @public
       * @param {Object}        the array,
       * @param {Number/string} the passed-in value,
       * @returns {Boolean}     returns true if the array contains the value,
       * @since 0.0.0
       */
      contains(list, value) {
        return list.indexOf(value) !== -1;
      },

      /**
       * Returns the list of the elements the passed-in arrays have in common.
       *
       * @method (arg)
       * @public
       * @param {Array}       n arrays to compare,
       * @returns {Array}     returns the list of elements in common or empty,
       * @since 0.0.0
       */
      share(array) {
        const result = [];
        let item
          , i
          , j
          ;

        for (i = 0; i < array.length; i++) {
          item = array[i];
          if (!this.contains(result, item)) {
            for (j = 1; j < arguments.length; j++) {
              /* eslint-disable-next-line prefer-rest-params */
              if (!this.contains(arguments[j], item)) {
                break;
              }
            }
            if (j === arguments.length) {
              result.push(item);
            }
          }
        }
        return result;
      },


      // -- Miscellaneous ------------------------------------------------------

      /**
       * Returns a unique string pattern in base 36 ([0-9a-z]).
       *
       * @method ()
       * @public
       * @param {}              -,
       * @returns {String}      returns a random string,
       * @since 0.0.0
       */
      token() {
        return Math.random().toString(36).substr(2);
      },


      // -- Extra --------------------------------------------------------------

      /**
       * Normalizes an object from { 'a.b': 1 } to { a: { b: 1 }}.
       *
       * @method (arg1)
       * @public
       * @param {Object}        the object,
       * @returns {Object}      returns the normalized object,
       * @since 0.0.0
       */
      normalize(obj) {
        return _normalize(obj);
      },
    };


    // -- Export
    $__TREE.extend($__TREE.src.lib._, _);

    /* eslint-enable one-var, semi-style, no-underscore-dangle */
  }());

  /* index: 3, path: 'src/private/count.js', import: [2, 10] */
  (function() {
    /** ************************************************************************
     *
     * Counts the number of documents into the db w.r.t. the filter.
     *
     * count.js is just a literal object that contains a set of functions.
     * It can't be instantiated.
     *
     * Private Functions:
     *  . _getArgs                    returns the filtered arguments,
     *  . _count                      counts the number of the documents in the db,
     *
     *
     * Public Static Methods:
     *  . _count                      counts the number of the documents in the db,
     *
     *
     *
     * @namespace    -
     * @dependencies none
     * @exports      -
     * @author       -
     * @since        0.0.0
     * @version      -
     * ********************************************************************** */
    /* - */
    /* eslint-disable one-var, semi-style, no-underscore-dangle */


    // -- Vendor Modules


    // -- Local Modules
    const { _ } = $__TREE.src.lib;
    const Q = $__TREE.src.private.query;


    // -- Local Constants


    // -- Local Variables


    // -- Private Functions ----------------------------------------------------

    /**
     * Returns the filtered arguments.
     *
     * @function (arg1, [arg2], [arg3])
     * @private
     * @param {object}          the query filter,
     * @param {object}          the passed-in options,
     * @param {Function}        the function to call at the completion,
     * @returns {Array}         returns an array with the filtered arguments,
     * @since 0.0.0
     */
    function _getArgs(...args) {
      // query, options, callback
      switch (args.length) {
        case 1:
          // must be query
          if (_.isLiteralObject(args[0])) {
            return [args[0], {}, null];
          }
          if (_.isFunction(args[0])) {
            return [null, {}, args[0]];
          }
          return [null, {}, args[0]];

        case 2:
          // must be query, options or query, callback
          if (_.isLiteralObject(args[0])) {
            if (_.isLiteralObject(args[1])) {
              return [args[0], args[1], null];
            }
            if (_.isFunction(args[1])) {
              return [args[0], {}, args[1]];
            }
            return [args[0], {}, null];
          }
          if (_.isFunction(args[1])) {
            return [null, {}, args[1]];
          }
          return [null, {}, null];

        case 3:
          // must be query, options, callback
          if (_.isLiteralObject(args[0])) {
            if (_.isLiteralObject(args[1])) {
              if (_.isFunction(args[2])) {
                return [args[0], args[1], args[2]];
              }
              return [args[0], args[1], null];
            }
            if (_.isFunction(args[2])) {
              return [args[0], {}, args[2]];
            }
            return [args[0], {}, null];
          }
          if (_.isFunction(args[2])) {
            return [null, {}, args[2]];
          }
          return [null, {}, args[2]];

        default:
          return [null, {}, null];
      }
    }

    /**
     * Counts the number of the documents contained in the db.
     *
     * @function (arg1, arg2, arg3, arg4)
     * @private
     * @param {Object}          the db,
     * @param {Object}          the query filter,
     * @param {Object}          the options,
     * @param {Function}        the function to call at the completion,
     * @returns {}              -,
     * @since 0.0.0
     */
    function _count(db, query, options, callback) {
      if (!query) {
        callback(null, 0);
        return;
      }

      const sop = Q.isHavingSpecialOperator(query);
      let count = 0;
      for (let i = 0; i < db.data.length; i++) {
        if (Q.isMatch(db.data[i], query, sop)) {
          count += 1;
        }
      }
      callback(null, count);
    }


    // -- Public Static Methods ------------------------------------------------

    const Count = {

      /**
       * Counts the number of the documents contained in the db
       *
       * @method (arg1, arg2, arg3, [arg4])
       * @public
       * @param {Object}        the database object,
       * @param {Object}        the query filter object,
       * @param {Object}        the optional settings,
       * @param {Function}      the function to call at the completion,
       * @returns {Object}      returns a promise,
       * @since 0.0.0
       */
      count(db, ...args) {
        const [query, options, callback] = _getArgs(...args);

        return new Promise((resolve, reject) => {
          _count(db, query, options, (err, resp) => {
            if (err) {
              reject(err);
              if (callback) callback(err);
            } else {
              resolve(resp);
              if (callback) callback(null, resp);
            }
          });
        });
      },
    };


    // -- Export
    $__TREE.extend($__TREE.src.private.count, Count);

    /* eslint-enable one-var, semi-style, no-underscore-dangle */
  }());

  /* index: 4, path: 'src/private/delete.js', import: [2, 10] */
  (function() {
    /** ************************************************************************
     *
     * Deletes the requested documents from the database.
     *
     * delete.js is just a literal object that contains a set of functions.
     * It can't be instantiated.
     *
     * Private Functions:
     *  . _getArgs                    returns the filtered arguments,
     *  . _delete                     deletes the requested documents from the db,
     *
     *
     * Public Static Methods:
     *  . _delete                     deletes the requested documents from the db,
     *
     *
     *
     * @namespace    -
     * @dependencies none
     * @exports      -
     * @author       -
     * @since        0.0.0
     * @version      -
     * ********************************************************************** */
    /* - */
    /* eslint-disable one-var, semi-style, no-underscore-dangle */


    // -- Vendor Modules


    // -- Local Modules
    const { _ } = $__TREE.src.lib;
    const Q = $__TREE.src.private.query;


    // -- Local Constants


    // -- Local Variables


    // -- Private Functions ----------------------------------------------------

    /**
     * Returns the filtered arguments.
     *
     * @function (arg1, [arg2], [arg3])
     * @private
     * @param {object}          the query filter,
     * @param {object}          the passed-in options,
     * @param {Function}        the function to call at the completion,
     * @returns {Array}         returns an array with the filtered arguments,
     * @since 0.0.0
     */
    function _getArgs(...args) {
      // filter, options, callback
      switch (args.length) {
        case 1:
          // must be filter or callback
          if (_.isLiteralObject(args[0])) {
            return [args[0], {}, null];
          }
          if (_.isFunction(args[0])) {
            return [null, {}, args[0]];
          }
          return [null, {}, null];

        case 2:
          // must be filter, options or filter, callback
          if (_.isLiteralObject(args[0])) {
            if (_.isLiteralObject(args[1])) {
              return [args[0], args[1], null];
            }
            if (_.isFunction(args[1])) {
              return [args[0], {}, args[1]];
            }
            return [args[0], {}, null];
          }
          if (_.isFunction(args[1])) {
            return [null, null, args[1]];
          }
          return [null, null, null];

        case 3:
          // must be filter, options, callback
          if (_.isLiteralObject(args[0])) {
            if (_.isLiteralObject(args[1])) {
              if (_.isFunction(args[2])) {
                return [args[0], args[1], args[2]];
              }
              return [args[0], args[1], null];
            }
            if (_.isFunction(args[2])) {
              return [args[0], {}, args[2]];
            }
            return [args[0], {}, null];
          }
          if (_.isFunction(args[2])) {
            return [null, null, args[2]];
          }
          return [null, null, null];

        default:
          return [null, null, null];
      }
    }

    /**
     * Deletes the requested documents from the db.
     *
     * @function (arg1, arg2, arg3, arg4, arg5, arg6)
     * @private
     * @param {object}          the db object,
     * @param {object}          the messenger object,
     * @param {Boolean}         deletes one or many,
     * @param {Object}          the query filter,
     * @param {object}          the passed-in options,
     * @param {Function}        the function to call at the completion,
     * @returns {}              -,
     * @since 0.0.0
     */
    function _delete(db, mess, many, filter, options, callback) {
      if (!filter) {
        callback(null, 0);
        return;
      }

      let docOut = []
        , removed
        , dblength
        ;

      // Parse the documents into the db one by one and check if the keys match:
      // (each time a document is deleted, the counter and the length size must
      // be reajusted. It could have been easier to parse the db from the last
      // to the first but in case of deleteOne it deletes the most recent
      // instead of the oldest)
      const sop = Q.isHavingSpecialOperator(filter);
      docOut = [];
      removed = 0;
      dblength = db.data.length;
      // for (i = db.data.length - 1; i >= 0; i--) {
      for (let i = 0; i < dblength; i++) {
        if (Q.isMatch(db.data[i], filter, sop)) {
          // Remove the document that matches:
          docOut.push(db.data.splice(i, 1)[0]);
          removed += 1;
          // Readjust db length after one item has been removed & reposition i:
          i -= 1;
          dblength -= 1;
          if (!many) {
            // Remove one document only!
            break;
          }
        }
      }

      // Fire an event and execute the callback:
      if (mess) {
        mess.publish('delete', docOut);
        mess.publish('change', docOut);
      }
      callback(null, removed);
    }


    // -- Public Static Methods ------------------------------------------------

    const Delete = {

      /**
       * Deletes the requested documents from the db.
       *
       * @method (arg1, arg2, arg3, arg4, arg5, arg6)
       * @public
       * @param {object}          the db object,
       * @param {object}          the messenger object,
       * @param {Boolean}         deletes one or many,
       * @param {Object}          the query filter,
       * @param {object}          the passed-in options,
       * @param {Function}        the function to call at the completion,
       * @returns {Object}        returns a promise,
       * @since 0.0.0
       */
      delete(db, mess, many, ...args) {
        const [filter, options, callback] = _getArgs(...args);

        return new Promise((resolve, reject) => {
          _delete(db, mess, many, filter, options, (err, resp) => {
            if (err) {
              reject(err);
              if (callback) callback(err);
            } else {
              resolve(resp);
              if (callback) callback(null, resp);
            }
          });
        });
      },
    };


    // -- Export
    $__TREE.extend($__TREE.src.private.delete, Delete);

    /* eslint-enable one-var, semi-style, no-underscore-dangle */
  }());

  /* index: 5, path: 'src/private/find.js', import: [2, 11, 10] */
  (function() {
    /** ************************************************************************
     *
     * Extracts the requested document(s) from the database.
     *
     * find.js is just a literal object that contains a set of functions.
     * It can't be instantiated.
     *
     * Private Functions:
     *  . _initCursor                 returns the default cursor object,
     *  . _getArgs                    returns the filtered arguments,
     *  . _toArray                    returns the found documents,
     *  . _find                       creates the cursor w.r.t to the query & proj,
     *
     *
     * Public Static Methods:
     *  . initCursor                  returns the default cursor object,
     *  . find                        creates the cursor w.r.t to the query & proj,
     *  . toArray                     returns the found documents,
     *
     *
     *
     * @namespace    -
     * @dependencies none
     * @exports      -
     * @author       -
     * @since        0.0.0
     * @version      -
     * ********************************************************************** */
    /* - */
    /* eslint-disable one-var, semi-style, no-underscore-dangle */


    // -- Vendor Modules


    // -- Local Modules
    const { _ } = $__TREE.src.lib;
    const P = $__TREE.src.private.projection;
    const Q = $__TREE.src.private.query;


    // -- Local Constants


    // -- Local Variables


    // -- Private Functions ----------------------------------------------------

    /**
     * Returns the default cursor object.
     *
     * @function ()
     * @private
     * @param {}                -,
     * @returns {Object}        returns the default cursor object,
     * @since 0.0.0
     */
    function _initCursor() {
      return {
        query: {},
        projection: {
          type: null,
          value: null,
        },
      };
    }

    /**
     * Returns the filtered arguments.
     *
     * @function (arg1, [arg2])
     * @private
     * @param {object}          the query filter,
     * @param {object}          the passed-in options,
     * @returns {Array}         returns an array with the filtered arguments,
     * @since 0.0.0
     */
    function _getArgs(...args) {
      return [
        _.isLiteralObject(args[0]) ? args[0] : {},
        _.isLiteralObject(args[1]) ? args[1] : {},
      ];
    }

    /**
     * Returns the found documents.
     *
     * @function (arg1, arg2, arg3)
     * @private
     * @param {Object}          the db object,
     * @param {Object}          the cursor object,
     * @param {Function}        the function to call at the completion,
     * @returns {}              -,
     * @since 0.0.0
     */
    function _toArray(db, cursor, callback) {
      /* istanbul ignore next */
      if (!cursor.query) {
        callback('This query isn\'t a valid Cursor query object');
        return;
      }

      // Parse the database:
      const sop = Q.isHavingSpecialOperator(cursor.query);
      const docs = [];
      for (let i = 0; i < db.data.length; i++) {
        if (Q.isMatch(db.data[i], cursor.query, sop)) {
          P.add(docs, db.data[i], cursor.projection);
        }
      }
      callback(null, docs);
    }

    /**
     * Creates the cursor w.r.t to the query filter and the projection.
     *
     * @function (arg1, arg2, [arg3])
     * @private
     * @param {Object}          the cursor object,
     * @param {Object}          the query filter,
     * @param {Object}          the projection,
     * @returns {}              -,
     * @since 0.0.0
     */
    /* eslint-disable no-param-reassign */
    function _find(cursor, query, projection) {
      cursor.query = query;
      cursor.projection.type = P.isProjectionTypeInclude(projection);
      cursor.projection.value = P.setProjection(projection, cursor.projection.type);
    }
    /* eslint-enable no-param-reassign */


    // -- Public Static Methods ------------------------------------------------

    const FA = {

      /**
       * Returns the default cursor.
       *
       * @method ()
       * @public
       * @param {}              -,
       * @returns {Object}      returns the default cursor,
       * @since 0.0.0
       */
      initCursor() {
        return _initCursor();
      },

      /**
       * Creates the cursor w.r.t to the query filter and the projection.
       *
       * @method (arg1, arg2, [arg3])
       * @public
       * @param {Object}        the cursor object,
       * @param {Object}        the query filter,
       * @param {Object}        the projection,
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      find(cursor, ...args) {
        const [query, projection] = _getArgs(...args);
        _find(cursor, query, projection);
        return this;
      },

      /**
       * Returns the found documents.
       *
       * @method (arg1, arg2, [arg3])
       * @public
       * @param {Object}        the cursor object,
       * @param {Object}        the query filter,
       * @param {Object}        the projection,
       * @returns {Object}      returns a promise,
       * @since 0.0.0
       */
      toArray(db, cursor, cb) {
        const callback = _.isFunction(cb) ? cb : null;

        return new Promise((resolve, reject) => {
          _toArray(db, cursor, (err, resp) => {
            if (err) {
              reject(err);
              if (callback) callback(err);
            } else {
              resolve(resp);
              if (callback) callback(null, resp);
            }
          });
        });
      },
    };


    // -- Export
    $__TREE.extend($__TREE.src.private.find, FA);

    /* eslint-enable one-var, semi-style, no-underscore-dangle */
  }());

  /* index: 6, path: 'src/private/insert.js', import: [2] */
  (function() {
    /** ************************************************************************
     *
     * A set of functions to insert new documents into the db.
     *
     * insert.js is just a literal object that contains a set of functions.
     * It can't be instantiated.
     *
     * Private Functions:
     *  . _getArgs                    returns the filtered arguments,
     *  . _schema                     returns the db model,
     *  . _isNewId                    checks that this 'id' is new,
     *  . _process                    inserts the new documents into the db,
     *  . _insert                     inserts the new documents into the db,
     *
     *
     * Public Static Methods:
     *  . schema                      returns the db model,
     *  . insert                      inserts the new documents into the db,
     *
     *
     *
     * @namespace    -
     * @dependencies none
     * @exports      -
     * @author       -
     * @since        0.0.0
     * @version      -
     * ********************************************************************** */
    /* - */
    /* eslint-disable one-var, semi-style, no-underscore-dangle */


    // -- Vendor Modules


    // -- Local Modules
    const { _ } = $__TREE.src.lib;


    // -- Local Constants


    // -- Local Variables


    // -- Private Functions ----------------------------------------------------

    /**
     * Returns the filtered arguments.
     *
     * @function (arg1, [arg2], arg3)
     * @private
     * @param {Array/Object}    the new document(s),
     * @param {Object}          the settings,
     * @param {Function}        the function to call at the completion,
     * @returns {Array}         returns the filtered arguments,
     * @since 0.0.0
     */
    function _getArgs(...args) {
      // docs, options, callback
      switch (args.length) {
        case 1:
          // must be docs or fn
          if (_.isArray(args[0]) || _.isLiteralObject(args[0])) {
            return [args[0], {}, null];
          }
          if (_.isFunction(args[0])) {
            return [[], {}, args[0]];
          }
          return [[], {}, null];

        case 2:
          // must be docs, options or docs, callback
          if (_.isArray(args[0]) || _.isLiteralObject(args[0])) {
            if (_.isLiteralObject(args[1])) {
              return [args[0], args[1], null];
            }
            if (_.isFunction(args[1])) {
              return [args[0], {}, args[1]];
            }
            return [args[0], {}, null];
          }
          if (_.isFunction(args[1])) {
            return [[], {}, args[1]];
          }
          return [[], {}, null];

        case 3:
          // must be docs, options, callback
          if (_.isArray(args[0]) || _.isLiteralObject(args[0])) {
            if (_.isLiteralObject(args[1])) {
              if (_.isFunction(args[2])) {
                return [args[0], args[1], args[2]];
              }
              return [args[0], args[1], null];
            }
            if (_.isFunction(args[2])) {
              return [args[0], {}, args[2]];
            }
            return [args[0], {}, null];
          }
          if (_.isFunction(args[2])) {
            return [[], {}, args[2]];
          }
          return [[], {}, null];

        default:
          return [[], {}, null];
      }
    }

    /**
     * Returns the db model.
     *
     * @function ()
     * @private
     * @param {}                -,
     * @returns {Object}        returns the db object model,
     * @since 0.0.0
     */
    function _schema() {
      return {
        data: [],
      };
    }

    /**
     * Checks that this 'id' is new.
     *
     * @function (arg1, arg2)
     * @private
     * @param {Object}          the database object,
     * @param {String}          the new id,
     * @returns {Boolean}       returns true if the id is new, false otherwise,
     * @since 0.0.0
     */
    function _isNewId(db, id) {
      let status = true;
      for (let i = 0; i < db.data.length; i++) {
        if (db.data[i]._id === id) {
          status = false;
          break;
        }
      }
      return status;
    }

    /**
     * Inserts the new documents into the db.
     *
     * @function (arg1, arg2, arg3, arg4, arg5)
     * @private
     * @param {Object}          the database object,
     * @param {Object}          the messenger object,
     * @param {Array/Object}    the new document(s),
     * @param {Object}          the settings,
     * @param {Function}        the function to call at the completion,
     * @returns {}              -,
     * @since 0.0.0
     */
    function _process(db, mess, docs, options, callback) {
      // Embed a single document in an array to get a generic process.
      let arr = [];
      if (_.isLiteralObject(docs)) {
        arr.push(docs);
      } else {
        arr = docs;
      }

      // Parse all the documents:
      const docOut = [];
      for (let i = 0; i < arr.length; i++) {
        if (_.isLiteralObject(arr[i])) {
          if (arr[i]._id) {
            // Do not duplicate doc!
            if (_isNewId(db, arr[i]._id)) {
              // Do not copy the references. Create new objects!
              db.data.push(_.extend({}, arr[i]));
              // Do not pass references to the db. Provide a copy instead!
              docOut.push(_.extend({}, arr[i]));
              if (!options.many) {
                break;
              }
            }
          } else {
            const id = _.token();
            db.data.push(_.extend({ _id: id }, arr[i]));
            docOut.push(_.extend({ _id: id }, arr[i]));
            if (!options.many) {
              // insert only the first document if many is false!
              break;
            }
          }
        }
      }

      // Fire an event and execute the callback:
      if (mess) {
        mess.publish('change', docOut);
        mess.publish('insert', docOut);
      }
      callback(null, docOut);
    }

    /**
     * Inserts the new documents into the db.
     *
     * @function (arg1, arg2, arg3, arg4, arg5)
     * @private
     * @param {Object}          the database object,
     * @param {Object}          the messenger object,
     * @param {Boolean}         true if many, false if one,
     * @param {Array/Object}    the new document(s),
     * @param {Object}          the settings,
     * @param {Function}        the function to call at the completion,
     * @returns {}              -,
     * @since 0.0.0
     */
    /* eslint-disable no-param-reassign */
    function _insert(db, mess, many, docs, options, callback) {
      // Insert if it is a valid document:
      options.many = many;
      if (many && _.isArray(docs)) {
        _process(db, mess, docs, options, callback);
        return;
      }
      if (!many && (_.isArray(docs) || _.isLiteralObject(docs))) {
        _process(db, mess, docs, options, callback);
        return;
      }
      callback(null, []);
    }
    /* eslint-enable no-param-reassign */


    // -- Public Static Methods ------------------------------------------------

    const Insert = {

      /**
       * Returns the db model.
       *
       * @method ()
       * @public
       * @param {}              -,
       * @returns {Object}      returns the db object model,
       * @since 0.0.0
       */
      schema() {
        return _schema();
      },

      /**
       * Inserts the new documents into the db.
       *
       * @method (arg1, arg2, arg3, arg4, [arg5])
       * @public
       * @param {Object}        the database object,
       * @param {Object}        the messenger object,
       * @param {Boolean}       true if many, false if one,
       * @param {Array/Object}  the new document(s),
       * @param {Object}        the settings,
       * @param {Function}      the function to call at the completion,
       * @returns {Object}      returns a promise,
       * @since 0.0.0
       */
      insert(db, mess, many, ...args) {
        const [docs, options, callback] = _getArgs(...args);

        return new Promise((resolve, reject) => {
          _insert(db, mess, many, docs, options, (err, resp) => {
            if (err) {
              reject(err);
              if (callback) callback(err);
            } else {
              resolve(resp);
              if (callback) callback(null, resp);
            }
          });
        });
      },
    };


    // -- Export
    $__TREE.extend($__TREE.src.private.insert, Insert);

    /* eslint-enable one-var, semi-style, no-underscore-dangle */
  }());

  /* index: 7, path: 'src/private/update.js', import: [2, 10] */
  (function() {
    /** ************************************************************************
     *
     * Updates the requested documents into the database.
     *
     * update.js is just a literal object that contains a set of functions.
     * It can't be instantiated.
     *
     * Private Functions:
     *  . _getArgs                    returns the filtered arguments,
     *  . _pull                       processes the $pull operator,
     *  . _push                       processes the $push operator,
     *  . _apply                      applies the requested update to the document,
     *  . _replace                    replaces the document content,
     *  . _applyTime                  updates or adds the time fields to the document,
     *  . _updateThisDoc              updates this document,
     *  . _update                     updates the requested document(s),
     *
     *
     * Public Static Methods:
     *  . update                      updates the requested document(s),
     *
     *
     *
     * @namespace    -
     * @dependencies none
     * @exports      -
     * @author       -
     * @since        0.0.0
     * @version      -
     * ********************************************************************** */
    /* - */
    /* eslint-disable one-var, semi-style, no-underscore-dangle */


    // -- Vendor Modules


    // -- Local Modules
    const { _ } = $__TREE.src.lib;
    const Q = $__TREE.src.private.query;


    // -- Local Constants


    // -- Local Variables


    // -- Private Functions ----------------------------------------------------

    /**
    * Returns the filtered arguments.
    *
    * @function (arg1, [arg2], [arg3])
    * @private
    * @param {object}          the query filter,
    * @param {object}          the passed-in options,
    * @param {Function}        the function to call at the completion,
    * @returns {Array}         returns an array with the filtered arguments,
     * @since 0.0.0
     */
    function _getArgs(...args) {
      // query, update, options, callback
      switch (args.length) {
        case 1:
          // must be callback
          if (_.isFunction(args[0])) {
            return [null, null, {}, args[0]];
          }
          return [null, null, {}, null];

        case 2:
          // must be query, update or query, callback
          if (_.isLiteralObject(args[0])) {
            if (_.isLiteralObject(args[1])) {
              return [args[0], args[1], {}, null];
            }
            if (_.isFunction(args[1])) {
              return [null, null, {}, args[1]];
            }
            return [null, null, {}, null];
          }
          if (_.isFunction(args[1])) {
            return [null, null, {}, args[1]];
          }
          return [null, null, {}, null];

        case 3:
          // must be query, update, options or query, update, callback
          if (_.isLiteralObject(args[0]) && _.isLiteralObject(args[1])) {
            if (_.isLiteralObject(args[2])) {
              return [args[0], args[1], args[2], null];
            }
            if (_.isFunction(args[2])) {
              return [args[0], args[1], {}, args[2]];
            }
            return [args[0], args[1], {}, null];
          }
          if (_.isFunction(args[2])) {
            return [null, null, {}, args[2]];
          }
          return [null, null, {}, null];


        case 4:
          // must be query, update, options, callback
          if (_.isLiteralObject(args[0]) && _.isLiteralObject(args[1])) {
            if (_.isLiteralObject(args[2])) {
              if (_.isFunction(args[3])) {
                return [args[0], args[1], args[2], args[3]];
              }
              return [args[0], args[1], args[2], null];
            }
            if (_.isFunction(args[3])) {
              return [args[0], args[1], {}, args[3]];
            }
            return [args[0], args[1], {}, null];
          }
          if (_.isFunction(args[3])) {
            return [null, null, {}, args[3]];
          }
          return [null, null, {}, null];

        default:
          return [null, null, {}, null];
      }
    }

    /**
     * Processes the $pull operator.
     * ({ $pull: { <field1>: <value|condition>, <field2>: <value|condition>, ... } })
     *
     * Note: this function mutates the argument `obj`.
     *
     * @function (arg1, arg2)
     * @private
     * @param {Object}          the destination document,
     * @param {Object}          the source document,
     * @returns {Object}        the modified document,
     * @since 0.0.0
     */
    /* eslint-disable no-restricted-syntax, no-param-reassign, dot-notation, no-continue */
    function _pull(obj, source) {
      let prop
        , key
        , match
        , index
        , op
        , arr
        , i
        ;

      for (prop in source) {
        // subprop = _.keys(source[prop]);
        if (_.isObject(source[prop]) && !_.isArray(obj[prop])) {
          if (obj[prop]) {
            _pull(obj[prop], source[prop]);
          }
        } else if (hasOwnProperty.call(source, prop)) {
          // If it doesn't exist or it isn't an array, go next:
          if (!obj[prop] || !_.isArray(obj[prop])) {
            continue;
          }

          // Boolean, Number or String, remove value:
          // (source be equivalent to: orders: 'y')
          if (typeof source[prop] === 'boolean' || typeof source[prop] === 'number' || typeof source[prop] === 'string') {
            index = obj[prop].indexOf(source[prop]);
            if (index > -1) {
              obj[prop].splice(index, 1);
            }
            continue;
          }

          // Object on Array, remove matching objects from array:
          // source be equivalent to: quantity: { a: 1, b: 2 })
          if (_.isObject(source[prop]) && !_.keys(source[prop])[0].match(/^\$/)) {
            // Parse objects:
            for (i = obj[prop].length - 1; i >= 0; i--) {
              if (!_.isObject(obj[prop][i])) {
                break;
              }

              // Do they match?
              match = true;
              for (key in source[prop]) {
                if (obj[prop][i][key] !== source[prop][key]) {
                  match = false;
                  break;
                }
              }
              if (match) {
                obj[prop].splice(i, 1);
              }
            }
            continue;
          }

          // Object, execute condition:
          // (source be equivalent to: ratings: { values: { $nin: ['cd'] })
          if (_.isObject(source[prop])) {
            [op] = _.keys(source[prop]);
            switch (op) {
              case '$eq':
                index = obj[prop].indexOf(source[prop]['$eq']);
                if (index > -1) {
                  obj[prop].splice(index, 1);
                }
                break;

              case '$gt':
                for (i = obj[prop].length - 1; i >= 0; i--) {
                  if (obj[prop][i] > source[prop]['$gt']) {
                    obj[prop].splice(i, 1);
                  }
                }
                break;

              case '$gte':
                for (i = obj[prop].length - 1; i >= 0; i--) {
                  if (obj[prop][i] >= source[prop]['$gte']) {
                    obj[prop].splice(i, 1);
                  }
                }
                break;

              case '$lt':
                for (i = obj[prop].length - 1; i >= 0; i--) {
                  if (obj[prop][i] < source[prop]['$lt']) {
                    obj[prop].splice(i, 1);
                  }
                }
                break;

              case '$lte':
                for (i = obj[prop].length - 1; i >= 0; i--) {
                  if (obj[prop][i] <= source[prop]['$lte']) {
                    obj[prop].splice(i, 1);
                  }
                }
                break;

              case '$ne':
                for (i = obj[prop].length - 1; i >= 0; i--) {
                  if (obj[prop][i] !== source[prop]['$ne']) {
                    obj[prop].splice(i, 1);
                  }
                }
                break;

              case '$in':
                if (!_.isArray(source[prop]['$in'])) {
                  break;
                }

                for (i = 0; i < source[prop]['$in'].length; i++) {
                  index = obj[prop].indexOf(source[prop]['$in'][i]);
                  if (index > -1) {
                    obj[prop].splice(index, 1);
                  }
                }
                break;

              case '$nin':
                if (!_.isArray(source[prop]['$nin'])) {
                  break;
                }

                arr = [];
                for (i = 0; i < source[prop]['$nin'].length; i++) {
                  index = obj[prop].indexOf(source[prop]['$nin'][i]);
                  if (index > -1) {
                    arr.push(source[prop]['$nin'][i]);
                  }
                }
                obj[prop] = _.clone(arr);
                break;

              /* istanbul ignore next */
              default:
                throw new Error(
                  `Update._pull: the operator "${op}" is not supported!`,
                );
            }
            continue;
          }
        }
      }
      return obj;
    }
    /* eslint-enable no-restricted-syntax, no-param-reassign, dot-notation, no-continue */

    /**
     * Processes the $push operator.
     * (this function mutates the argument `obj`).
     *
     * @function (arg1, arg2)
     * @private
     * @param {Object}          the destination document,
     * @param {Object}          the source document,
     * @returns {Object}        returns the modified document,
     * @since 0.0.0
     */
    /* eslint-disable no-restricted-syntax, no-param-reassign, dot-notation, no-continue */
    function _push(obj, source) {
      let prop
        , subprop
        , position
        , slice
        , i
        ;

      for (prop in source) {
        if (!{}.hasOwnProperty.call(source, prop)) {
          continue;
        }

        subprop = _.keys(source[prop]);
        if (!_.isArray(source[prop]) && _.isObject(source[prop]) && /* !_.contains(subprop, '$each') */ !subprop[0].match(/^\$/)) {
          if (!obj[prop]) {
            obj[prop] = {};
          }
          _push(obj[prop], source[prop]);
        } else if (hasOwnProperty.call(source, prop)) {
          if (!obj[prop]) {
            obj[prop] = [];
          }

          // Boolean, Number or String:
          if (typeof source[prop] === 'boolean' || typeof source[prop] === 'number' || typeof source[prop] === 'string') {
            obj[prop].push(source[prop]);
            continue;
          }

          // Array:
          if (_.isArray(source[prop])) {
            obj[prop].push(_.clone(source[prop]));
            continue;
          }

          // Object with Update Operator Modifiers: $each, $sort, $position
          if (_.isObject(source[prop]) && _.isArray(source[prop]['$each'])) {
            // Position in the array to insert elements:
            position = source[prop]['$position'];
            if (position === undefined || typeof position !== 'number' || position < 0) {
              position = obj[prop].length;
            }

            // Slice:
            slice = source[prop]['$slice'];
            if (slice === undefined || typeof position !== 'number') {
              slice = null;
            }

            // Update the array from position:
            for (i = source[prop]['$each'].length - 1; i >= 0; i--) {
              obj[prop].splice(position, 0, source[prop]['$each'][i]);
            }

            // Slice the array
            if (slice > 0) {
              obj[prop].splice(slice, obj[prop].length - slice);
            } else if (slice === 0) {
              obj[prop].length = 0;
            } else if (slice < 0) {
              obj[prop].splice(0, obj[prop].length + slice);
            }
          }
        }
      }
      return obj;
    }
    /* eslint-enable no-restricted-syntax, no-param-reassign, dot-notation, no-continue */

    /**
     * Applies the requested update to the document.
     * (this function mutates the argument `obj`)
     *
     * @function (arg1, arg2, arg3)
     * @private
     * @param {Object}          the destination document,
     * @param {Object}          the source document,
     * @param {String}          the Update Operator,
     * @returns {Object}        the modified document,
     * @throws {Object}         throws an error if the operator is unknown,
     * @since 0.0.0
     */
    /* eslint-disable no-restricted-syntax, no-param-reassign, dot-notation */
    function _apply(obj, source, op) {
      let prop
        , i
        , j
        ;

      for (prop in source) {
        if (!_.isArray(source[prop]) && _.isObject(source[prop])) {
          if (!obj[prop] && (op === '$rename' || op === '$unset' || op === '$pop')) {
            break;
          } else if (!obj[prop]) {
            obj[prop] = {};
          }
          _apply(obj[prop], source[prop], op);
        } else if (hasOwnProperty.call(source, prop)) {
          // if (_.isArray(source[prop]))
          // obj[prop] = _.clone(source[prop]);
          // else
          switch (op) {
            // Field Operators:
            case '$inc':
              if (typeof obj[prop] === 'number') {
                obj[prop] += source[prop];
              } else {
                obj[prop] = source[prop];
              }
              break;

            case '$mul':
              if (typeof obj[prop] === 'number') {
                obj[prop] *= source[prop];
              } else {
                obj[prop] = 0;
              }
              break;

            case '$rename':
              if (obj[prop]) {
                obj[source[prop]] = obj[prop];
                delete obj[prop];
              }
              break;

            case '$set':
              if (_.isArray(source[prop])) {
                obj[prop] = _.clone(source[prop]);
              } else {
                obj[prop] = source[prop];
              }
              break;

            case '$unset':
              if (obj[prop]) {
                delete obj[prop];
              }
              break;

            case '$min':
              if (!obj[prop] || (typeof obj[prop] === 'number' && source[prop] < obj[prop])) {
                obj[prop] = source[prop];
              }
              break;

            case '$max':
              if (!obj[prop] || (typeof obj[prop] === 'number' && source[prop] > obj[prop])) {
                obj[prop] = source[prop];
              }
              break;

            // Array Operators:
            case '$pop':
              if (_.isArray(obj[prop])) {
                if (source[prop] === 1) {
                  obj[prop].pop();
                } else if (source[prop] === -1) {
                  obj[prop].shift();
                }
              }
              break;

            case '$pullAll':
              if (_.isArray(obj[prop]) && _.isArray(source[prop])) {
                for (i = 0; i < source[prop].length; i++) {
                  for (j = obj[prop].length - 1; j >= 0; j--) {
                    if (obj[prop][j] === source[prop][i]) {
                      obj[prop].splice(j, 1);
                    }
                  }
                }
              }
              break;

            /* istanbul ignore next */
            default:
              throw new Error(
                `Update._apply: the operator "${op}" is unknown!`,
              );
          }
        }
      }
      return obj;
    }
    /* eslint-enable no-restricted-syntax, no-param-reassign, dot-notation */

    /**
     * Replaces the document content.
     * (this function mutates the argument `obj`)
     *
     * @function (arg1, arg2)
     * @private
     * @param {Object}          the destination document,
     * @param {Object}          the source document,
     * @returns {Object}        returns the modified document,
     * @since 0.0.0
     */
    /* eslint-disable no-param-reassign */
    function _replace(obj, source) {
      const keys = _.keys(obj);

      // Delete all the properties of 'obj', except '_id':
      for (let i = 0; i < keys.length; i++) {
        if (keys[i] !== '_id') {
          delete obj[keys[i]];
        }
      }

      // Update 'obj' with the properties of 'source':
      return _.extend(obj, source);
    }
    /* eslint-enable no-param-reassign */

    /**
     * Updates or adds the time fields to the document.
     * (this function mutates the argument `obj`)
     *
     * If the type is 'timestamp' sets the timestamp. Otherwise sets the date.
     * The source document has the following form:
     * $currentDate: { lastModified: true, cancellation: { date: { $type: 'timestamp' }}
     *
     * @function (arg1, arg2)
     * @private
     * @param {Object}          the destination document,
     * @param {Object}          the source document,
     * @returns {Object}        returns the modified document,
     * @since 0.0.0
     */
    /* eslint-disable no-restricted-syntax, no-param-reassign */
    function _applyTime(obj, source) {
      let prop
        , subprop
        ;

      for (prop in source) {
        if ({}.hasOwnProperty.call(source, prop)) {
          [subprop] = _.keys(source[prop]);
          if (_.isObject(source[prop]) && subprop !== '$type') {
            if (!obj[prop]) {
              obj[prop] = {};
            }
            _applyTime(obj[prop], source[prop]);
          } else if (hasOwnProperty.call(source, prop)) {
            if (source[prop][subprop] === 'timestamp') {
              obj[prop] = Date.now();
            } else {
              obj[prop] = new Date().toISOString();
            }
          }
        }
      }
      return obj;
    }
    /* eslint-enable no-restricted-syntax, no-param-reassign */

    /**
     * Updates this document.
     * (this function mutates the argument `doc`)
     *
     * @function (arg1, arg2)
     * @private
     * @param {Object}          the document to update,
     * @param {Object}          the 'fields' to be updated and their new values,
     * @returns {Object}        returns the modified document,
     * @throws {Object}         throws an error if the operator is unknown or not supported,
     * @since 0.0.0
     */
    /* eslint-disable dot-notation */
    function _updateThisDoc(doc, update) {
      const keys = _.keys(update);

      if (!keys[0].match(/^\$/)) {
        return _replace(doc, update);
      }

      switch (keys[0]) {
        // Field Operators:
        case '$inc':
          return _apply(doc, update['$inc'], '$inc');

        case '$mul':
          return _apply(doc, update['$mul'], '$mul');

        case '$rename':
          return _apply(doc, update['$rename'], '$rename');

        case '$set':
          return _apply(doc, update['$set'], '$set');

        case '$unset':
          return _apply(doc, update['$unset'], '$unset');

        case '$min':
          return _apply(doc, update['$min'], '$min');

        case '$max':
          return _apply(doc, update['$max'], '$max');

        case '$currentDate':
          return _applyTime(doc, update['$currentDate']);

        // Array Operators:
        case '$pop':
          return _apply(doc, update['$pop'], '$pop');

        case '$pullAll':
          return _apply(doc, update['$pullAll'], '$pullAll');

        case '$pull':
          return _pull(doc, update['$pull'], '$pull');

        case '$push':
          return _push(doc, update['$push'], '$push');

        /* istanbul ignore next */
        default:
          throw new Error(
            `The Update Operator "${keys[0]}" isn't supported!`,
          );
      }
    }
    /* eslint-enable dot-notation */

    /**
     * Updates the requested document(s).
     *
     * @function (arg1, arg2, arg3, arg4, arg5, arg6, arg7)
     * @private
     * @param {Object}          the db object,
     * @param {Object}          the messenger object,
     * @param {Boolean}         updates one or many documents,
     * @param {Object}          the query filter,
     * @param {Object}          the replacing document,
     * @param {Object}          the options,
     * @param {Function}        the function to call at the completion,
     * @returns {String}        -,
     * @since 0.0.0
     */
    function _update(db, mess, many, query, update, options, callback) {
      if (!query || !update) {
        callback(null, []);
        return;
      }

      const sop    = Q.isHavingSpecialOperator(query)
          , docOut = []
          ;

      for (let i = 0; i < db.data.length; i++) {
        if (Q.isMatch(db.data[i], query, sop)) {
          _updateThisDoc(db.data[i], update);
          // Do not copy the references. Clone the object instead!
          docOut.push(_.extend({}, db.data[i]));
          if (!many) {
            break;
          }
        }
      }

      // Fire an event and execute the callback:
      if (mess) {
        mess.publish('update', docOut);
        mess.publish('change', docOut);
      }
      callback(null, docOut);
    }


    // -- Public Static Methods ------------------------------------------------

    const Update = {

      /**
       * Updates the requested document(s).
       *
       * @method (arg1, arg2, arg3, arg4, arg5, [arg6], [arg7])
       * @public
       * @param {Object}        the db object,
       * @param {Object}        the messenger object,
       * @param {Boolean}       updates one or many documents,
       * @param {Object}        the query filter,
       * @param {Object}        the replacing document,
       * @param {Object}        the options,
       * @param {Function}      the function to call at the completion,
       * @returns {Object}      returns a promise,
       * @since 0.0.0
       */
      update(db, mess, many, ...args) {
        const [query, update, options, callback] = _getArgs(...args);

        return new Promise((resolve, reject) => {
          _update(db, mess, many, query, update, options, (err, resp) => {
            if (err) {
              reject(err);
              if (callback) callback(err);
            } else {
              resolve(resp);
              if (callback) callback(null, resp);
            }
          });
        });
      },
    };


    // -- Export
    $__TREE.extend($__TREE.src.private.update, Update);

    /* eslint-enable one-var, semi-style, no-underscore-dangle */
  }());

  /* index: 8, path: 'src/lib/plugin.js', import: [2] */
  (function() {
    /** ************************************************************************
     *
     * Manages the plugin.
     *
     * plugin.js is just a literal object that contains a set of functions.
     * It can't be instantiated.
     *
     * Private Functions:
     *  . none,
     *
     *
     * Public Static Methods:
     *  .
     *
     *
     *
     * @namespace    -
     * @dependencies none
     * @exports      -
     * @author       -
     * @since        0.0.0
     * @version      -
     * ********************************************************************** */
    /* - */
    /* eslint-disable one-var, semi-style, no-underscore-dangle */


    // -- Vendor Modules
    const { _ } = $__TREE.src.lib;


    // -- Local Modules


    // -- Local Constants


    // -- Local Variables


    // -- Private Functions ----------------------------------------------------

    /**
     * Attaches a valid plugin.
     *
     * @function (arg1, arg2)
     * @private
     * @param {Object}          the plugin db,
     * @param {Function}        the plugin library,
     * @returns {Boolean}       returns true if it succeeds,
     * @since 0.0.0
     */
    function _plugin(db, plug) {
      if (_.isLiteralObject(plug)
        && plug.messenger && plug.messenger.NAME === 'Messenger') {
        /* eslint-disable-next-line no-param-reassign */
        db.messenger = plug.messenger;
        return true;
      }
      return false;
    }


    // -- Public Static Methods ------------------------------------------------

    const Plugin = {

      /**
       * The plugin db
       */
      _db: {
        messenger: null,
      },

      /**
       * Attaches a valid plugin.
       *
       * @method (arg1)
       * @public
       * @param {Object}        the plugin library,
       * @returns {Boolean}     returns true if it succeeds,
       * @since 0.0.0
       */
      plugin(plug) {
        return _plugin(this._db, plug);
      },

      /**
       * Returns the requested plugin.
       *
       * @method (arg1)
       * @public
       * @param {String}        the plugin name,
       * @returns {Function}    returns the requested plugin,
       * @since 0.0.0
       */
      get(plugin) {
        return _.isString(plugin) && this._db[plugin] ? this._db[plugin] : null;
      },
    };


    // -- Export
    $__TREE.extend($__TREE.src.lib.plugin, Plugin);

    /* eslint-enable one-var, semi-style, no-underscore-dangle */
  }());

  /* index: 9, path: 'src/private/geo.js', import: [2] */
  (function() {
    /** ************************************************************************
     *
     * A set of functions to make Geospatial queries.
     *
     * geo.js is just a literal object that contains a set of functions.
     * It can't be instantiated.
     *
     * Private Functions:
     *  . _lawOfHaversines            returns the distance between two points on earth,
     *  . _lawOfCosines               returns the distance between two points on earth,
     *  . _equirectangularProjection  returns the distance between two points on earth,
     *  . _getDistanceOnEarth         returns the distance between two points on earth
     *  . _isPointInPolygon2          checks if the point is inside the polygon,
     *  . _isPointInPolygon           checks if the point is inside the polygon,
     *  . _isGeometryInsideGeoObject  checks if the geo. is inside a Multi. or Polygon,
     *  . _toPolygonCoordinates       embeds Point, LineString and Polygon,
     *  . _box                        checks if the Geo matches the $geoWithin $box,
     *  . _polygon                    checks if the Geo matches the $geoWithin $polygon,
     *  . _center                     checks if the Geo matches the $geoWithin $center,
     *  . _centerSphere               checks if the Geo matches the $geoWithin $centerSphere,
     *  . _within                     checks if the Geo matches the $geoWithin $geometry,
     *  . _interLineString            checks if the Geo Line intersects $geoIntersects polygon,
     *  . _interPolygon               checks if the Geo Poly. intersects $geoIntersects polygon,
     *  . _intersects                 checks if the Geo obj. intersects $geoIntersects polygon,
     *  . _isPointNear                checks if the Geo Point matches the condition of distance,
     *  . _geoNear                    checks if the Geo object matches the $near query,
     *  . _geoWithin                  checks if the Geo object matches the $geoWithin query,
     *  . _geoIntersects              checks if the Geo object matches the $geoIntersects query,
     *  . _near                       checks if the Geo object matches the $near query.
     *  . _query                      decodes the GeoSpatial query.
     *
     *
     * Public Static Methods:
     *  . lawOfHaversines             returns the distance between two points on Earth,
     *  . lawOfCosines                returns the distance between two points on Earth,
     *  . equirectangularProjection   returns the distance between two points on Earth,
     *  . query                       processes the GeoSpatial query,
     *
     *
     *
     * @namespace    -
     * @dependencies none
     * @exports      -
     * @author       -
     * @since        0.0.0
     * @version      -
     * ********************************************************************** */
    /* - */
    /* eslint-disable one-var, semi-style, no-underscore-dangle */


    // -- Vendor Modules


    // -- Local Modules
    const { _ } = $__TREE.src.lib;


    // -- Local Constants


    // -- Local Variables


    // -- Private Functions ----------------------------------------------------

    /**
     * Returns the distance between two points on Earth using the law of haversines.
     *
     * `haversine` formula to calculate the great-circle distance between
     * two points:
     *
     *   a = sin²(Δφ/2) + cos φ1 ⋅ cos φ2 ⋅ sin²(Δλ/2)
     *   c = 2 ⋅ atan2( √a, √(1−a) )
     *   d = R ⋅ c
     *
     *   where φ is latitude, λ is longitude, R is earth’s radius
     *   (mean radius = 6,371km);
     *
     * @function (arg1, arg2)
     * @private
     * @param {Object}          the destination point,
     * @param {Object}          the source point,
     * @returns {Boolean}       returns the distance between the two points in meters,
     * @since 0.0.0
     */
    function _lawOfHaversines(obj, source) {
      const λ1 = source.coordinates[0]
          , λ2 = obj.coordinates[0]
          , Δλ = (λ2 - λ1) * (Math.PI / 180)
          , φ1 = source.coordinates[1] * (Math.PI / 180)
          , φ2 = obj.coordinates[1] * (Math.PI / 180)
          , Δφ = (φ2 - φ1)
          , R  = 6371e3
          ;

      const a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2)
          + Math.cos(φ1) * Math.cos(φ2)
          * Math.sin(Δλ / 2) * Math.sin(Δλ / 2);

      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

      return R * c;
    }

    /**
     * Returns the distance between two points on Earth using the law of cosines.
     *
     * Formula:
     *   d = acos( sin φ1 ⋅ sin φ2 + cos φ1 ⋅ cos φ2 ⋅ cos Δλ ) ⋅ R
     *
     * Nota:
     * This formula is slightly faster than the law of haversines while offering
     * a similar accuracy on distances greater than a few dozen meters.
     *
     * @function (arg1, arg2)
     * @private
     * @param {Object}          the destination point,
     * @param {Object}          the source point,
     * @returns {Boolean}       returns the distance between the two points in meters,
     * @since 0.0.0
     */
    function _lawOfCosines(obj, source) {
      const λ1 = source.coordinates[0]
          , λ2 = obj.coordinates[0]
          , Δλ = (λ2 - λ1) * (Math.PI / 180)
          , φ1 = source.coordinates[1] * (Math.PI / 180)
          , φ2 = obj.coordinates[1] * (Math.PI / 180)
          , R  = 6371e3
          ;

      return Math.acos(Math.sin(φ1) * Math.sin(φ2)
        + Math.cos(φ1) * Math.cos(φ2) * Math.cos(Δλ)) * R;
    }

    /**
     * Returns the distance between two points on Earth using
     * the Equirectangular projection.
     *
     * Formula:
     *   y = Δφ
     *   d = R ⋅ √x² + y²
     *
     * Nota:
     * This formula is faster than the law of cosines and the law of the haversines
     * but is less accurante on distances greater than a few hundred kilometers.
     *
     * @function (arg1, arg2)
     * @private
     * @param {Object}          the destination point,
     * @param {Object}          the source point,
     * @returns {Boolean}       returns the distance between the two points in meters,
     * @since 0.0.0
     */
    function _equirectangularProjection(obj, source) {
      const λ1 = source.coordinates[0] * (Math.PI / 180)
          , λ2 = obj.coordinates[0] * (Math.PI / 180)
          , φ1 = source.coordinates[1] * (Math.PI / 180)
          , φ2 = obj.coordinates[1] * (Math.PI / 180)
          , R  = 6371e3
          ;

      const x = (λ2 - λ1) * Math.cos((φ1 + φ2) / 2);
      const y = φ2 - φ1;
      return Math.sqrt(x * x + y * y) * R;
    }

    /**
     * Returns the distance between two points on Earth.
     *
     * Nota:
     * This function can rely on three algorithms to compute the distance from
     * two points on Earth: the law of haversines, the law of cosines and
     * the Equirectangular projection. The law of cosines is the currently used.
     *
     * These algorithms are taken from here:
     *   . http://www.movable-type.co.uk/scripts/latlong.html
     *
     * @function (arg1, arg2)
     * @private
     * @param {Object}          the destination point,
     * @param {Object}          the source point,
     * @returns {Boolean}       returns the distance between the two points in meters,
     * @since 0.0.0
     */
    function _getDistanceOnEarth(obj, source) {
      return _lawOfCosines(obj, source);
    }

    /**
     * Checks if the point is inside the polygon.
     *
     * The algorithm, determining the inclusion of a point P in a 2D planar polygon,
     * is based on the crossing number method.
     * This method counts the number of times a ray starting from the point P
     * crosses the polygon boundary edges. The point is outside when this
     * 'crossing number' is even; otherwise, when it is odd, the point is inside.
     * This method is sometimes referred to as the 'even-odd' test.
     * See here: http://geomalgorithms.com/a03-_inclusion.html#wn_PinPolygon()
     *
     * @function (arg1, arg2)
     * @private
     * @param {Object}          the coordinates of the point,
     * @param {Object}          the coordinates of the polygon,
     * @returns {Boolean}       returns true if the point is inside the polygon,
     * @since 0.0.1
     */
    /* eslint-disable-next-line */
    /* istanbul ignore next */ function _isPointInPolygon2(point, polygon) {
      let intersections
        , vertex1
        , vertex2
        , xinter
        ;

      // Check if the point is on a vertex:
      for (let i = 0; i < polygon.length; i++) {
        if (point[0] === polygon[i][0] && point[1] === polygon[i][1]) {
          return 'vertex';
        }
      }

      // Check if the point is inside the polygon or on the boundary:
      intersections = 0;

      for (let i = 1; i < polygon.length; i++) {
        vertex1 = polygon[i - 1];
        vertex2 = polygon[i];

        // Check if the point is on an horizontal boundary:
        if (vertex1[1] === vertex2[1] && vertex1[1] === point[1]
            && point[0] > Math.min(vertex1[0], vertex2[0])
            && point[0] < Math.max(vertex1[0], vertex2[0])) {
          return 'boundary';
        }

        if (point[1] > Math.min(vertex1[1], vertex2[1])
            && point[1] <= Math.max(vertex1[1], vertex2[1])
            && point[0] <= Math.max(vertex1[0], vertex2[0])
            && vertex1[1] !== vertex2[1]) {
          /* eslint-disable-next-line */
          xinter = (point[1] - vertex1[1]) * (vertex2[0] - vertex1[0]) / (vertex2[1] - vertex1[1]) + (vertex1[0]);
          // Check if the point is on a boundary other than the horizontal one:
          if (xinter === point[0]) {
            return 'boundary';
          }

          if (vertex1[0] === vertex2[0] || point[0] <= xinter) {
            intersections += 1;
          }
        }
      }
      return intersections % 2 !== 0 ? 'inside' : 'outside';
    }

    /**
     * Checks if the point is inside the polygon.
     *
     * @function (arg1, arg2)
     * @private
     * @param {Object}          the coordinates of the point,
     * @param {Object}          the coordinates of the polygon,
     * @returns {Boolean}       returns true if the point is inside the polygon,
     * @since 0.0.0
     */
    function _isPointInPolygon(point, polygon) {
      let cn = 0
        , vt
        ;

      for (let i = 0; i < polygon.length - 1; i++) {
        if (((polygon[i][1] <= point[1]) && (polygon[i + 1][1] > point[1]))
            || ((polygon[i][1] > point[1]) && (polygon[i + 1][1] <= point[1]))) {
          // compute  the actual edge-ray intersect x-coordinate:
          vt = (point[1] - polygon[i][1]) / (polygon[i + 1][1] - polygon[i][1]);
          if (point[0] < polygon[i][0] + vt * (polygon[i + 1][0] - polygon[i][0])) {
            cn += 1;
          }
        }
      }
      return cn % 2 !== 0;
    }

    /**
     * Checks if the GeoJSON geometry is inside a Multipolygon or Polygon.
     *
     * @function (arg1, arg2)
     * @private
     * @param {Array}           the GeoJSON geometry,
     * @param {Object}          the GeoSpatial $geoWithin/$geometry query,
     * @returns {Boolean}       returns true if the point is inside the Multipolygon/polygon,
     @ @throws {Object}         throws an error if the type isn't 'Multipolygon' or 'Polygon',
     * @since 0.0.0
     */
    function _isGeometryInsideGeoObject(obj, source) {
      let breakloop
        , l
        ;

      switch (source.type) {
        // The point is considered as inside a Multipolygon if it inside of
        // one ring of one polygon.
        case 'MultiPolygon':
          for (let i = 0; i < obj.length; i++) {
            for (let j = 0; j < obj[i].length; j++) {
              for (let k = 0; k < source.coordinates.length; k++) {
                breakloop = false;
                for (l = 0; l < source.coordinates[k].length; l++) {
                  if (_isPointInPolygon(obj[i][j], source.coordinates[k][l])) {
                    breakloop = true;
                    break;
                  }
                }
                if (breakloop) {
                  break;
                }
              }
              if (!breakloop) {
                return false;
              }
            }
          }
          return true;

        // The point is considered as inside a Polygon if it inside of
        // one ring of the polygon.
        case 'Polygon':
          for (let i = 0; i < obj.length; i++) {
            for (let j = 0; j < obj[i].length; j++) {
              breakloop = false;
              for (let k = 0; k < source.coordinates.length; k++) {
                if (_isPointInPolygon(obj[i][j], source.coordinates[k])) {
                  breakloop = true;
                  break;
                }
              }
              if (!breakloop) {
                return false;
              }
            }
          }
          return true;

        /* istanbul ignore next */
        default:
          throw new Error(
            `Geo._within: the GeoSpatial $geoWihin operator with a $geometry.type "${source.type}" is unknown!`,
          );
      }
    }

    /**
     * Embeds Point, LineString and Polygon coordinates inside a 'Polygon' like coordinate array.
     *
     * @function (arg1)
     * @private
     * @param {Object}          the GeoJSON object,
     * @returns {Array}         returns the embbedded coordinates,
     * @since 0.0.0
     */
    function _toPolygonCoordinates(obj) {
      switch (obj.type) {
        case 'Point':
          return [[obj.coordinates]];
        case 'LineString':
          return [obj.coordinates];
        case 'Polygon':
          return obj.coordinates;
        case 'MultiPoint':
          return [obj.coordinates];
        case 'MultiLineString':
          return obj.coordinates;

        /* istanbul ignore next */
        default:
          throw new Error(
            `Geo._toPolygonCoordinates: the GeoJSON type "${obj.type}" is not supported!`,
          );
      }
    }

    /**
     * Checks if the GeoJSON object matches the $geoWithin $box query.
     *
     * @function (arg1, arg2)
     * @private
     * @param {Object}          the GeoJSON object,
     * @param {Object}          the GeoSpatial $geoWithin/$box query,
     * @returns {Boolean}       returns true if the point is inside the box, false otherwise,
     * @since 0.0.0
     */
    function _box(obj, box) {
      const c = [[
        [box[0][0], box[0][1]],
        [box[1][0], box[0][1]],
        [box[1][0], box[1][1]],
        [box[0][0], box[1][1]],
      ]];

      const p = {
        type: 'Polygon',
        coordinates: c,
      };

      return _isGeometryInsideGeoObject(_toPolygonCoordinates(obj), p);
    }

    /**
     * Checks if the GeoJSON object matches the $geoWithin $polygon query.
     *
     * @function (arg1, arg2)
     * @private
     * @param {Object}          the GeoJSON object,
     * @param {Object}          the GeoSpatial $geoWithin/$polygon query,
     * @returns {Boolean}       returns true if the point is inside the polygon, false otherwise,
     * @since 0.0.0
     */
    function _polygon(obj, polygon) {
      // The polygon must be closed (last point === first point).
      const p = {
        type: 'Polygon',
        coordinates: [polygon, [polygon[0][0], polygon[0][1]]],
      };

      return _isGeometryInsideGeoObject(_toPolygonCoordinates(obj), p);
    }

    /**
     * Checks if the GeoJSON object matches the $geoWithin $center query.
     *
     * @function (arg1, arg2)
     * @private
     * @param {Object}          the GeoJSON object,
     * @param {Object}          the GeoSpatial $geoWithin/$geometry query,
     * @returns {Boolean}       returns true if the point is inside the circle, false otherwise,
     * @since 0.0.0
     */
    function _center(obj, center) {
      /* eslint-disable-next-line */
      const d = Math.sqrt(Math.pow((center[0][0] - obj.coordinates[0]), 2) + Math.pow((center[0][1] - obj.coordinates[1]), 2));
      return d < center[1];
    }

    /**
     * Checks if the GeoJSON object matches the $geoWithin $centerSphere query.
     *
     * @function (arg1, arg2)
     * @private
     * @param {Object}          the GeoJSON object,
     * @param {Object}          the GeoSpatial $geoWithin/$geometry query,
     * @returns {Boolean}       returns true if the point is inside the sphere, false otherwise,
     * @since 0.0.0
     */
    function _centerSphere(obj, centerSphere) {
      /* eslint-disable-next-line */
      const d = Math.sqrt(Math.pow((centerSphere[0][0] - obj.coordinates[0]), 2) + Math.pow((centerSphere[0][1] - obj.coordinates[1]), 2));
      /* eslint-disable-next-line */
      return d < (centerSphere[1] / Math.PI * 180);
    }

    /**
     * Checks if the GeoJSON object matches the $geoWithin $geometry query.
     *
     * @function (arg1, arg2)
     * @private
     * @param {Object}          the GeoJSON object,
     * @param {Object}          the GeoSpatial $geoWithin/$geometry query,
     * @returns {Boolean}       returns true if the point is inside the polygon, false otherwise,
     * @since 0.0.0
     */
    function _within(obj, source) {
      switch (obj.type) {
        case 'Point':
          return _isGeometryInsideGeoObject(_toPolygonCoordinates(obj), source);

        case 'LineString':
          return _isGeometryInsideGeoObject(_toPolygonCoordinates(obj), source);

        case 'Polygon':
          return _isGeometryInsideGeoObject(_toPolygonCoordinates(obj), source);

        case 'MultiPoint':
          return _isGeometryInsideGeoObject(_toPolygonCoordinates(obj), source);

        case 'MultiLineString':
          return _isGeometryInsideGeoObject(_toPolygonCoordinates(obj), source);

        /* istanbul ignore next */
        case 'MultiPolygon':
          return false;

        /* istanbul ignore next */
        case 'GeometryCollection':
          return false;

        /* istanbul ignore next */
        default:
          return false;
      }
    }

    /**
     * Checks if the GeoJSON type LineString intersects the $geoIntersects polygon.
     *
     * @function (arg1, arg2)
     * @private
     * @param {Object}          the GeoJSON object,
     * @param {Object}          the GeoSpatial query,
     * @returns {Boolean}       returns true if the query is successful, false otherwise,
     * @since 0.0.0
     */
    function _interLineString(obj, source) {
      let inside
        , outside
        , breakloop
        ;

      // It matches if one point of the LineString, at least, is inside the polygon
      // and one point, at least, is outside the polygon.
      for (let i = 0; i < obj.coordinates.length; i++) {
        for (let j = 0; j < source.coordinates.length; j++) {
          breakloop = false;
          if (_isPointInPolygon(obj.coordinates[i], source.coordinates[j])) {
            inside = true;
            breakloop = true;
            // Abort as soon as we have found one point inside and one point ouside!
            if (inside && outside) {
              return true;
            }
            break;
          }
        }
        if (!breakloop) {
          outside = true;
          if (inside && outside) {
            return true;
          }
        }
      }
      return false;
    }

    /**
     * Checks if the GeoJSON type Polygon intersects the $geoIntersects polygon.
     *
     * @function (arg1, arg2)
     * @private
     * @param {Object}          the GeoJSON object,
     * @param {Object}          the GeoSpatial query,
     * @returns {Boolean}       returns true if the query is successful, false otherwise,
     * @since 0.0.1
     */
    function _interPolygon(obj, source) {
      let inside
        , outside
        , breakloop
        ;

      for (let i = 0; i < obj.coordinates.length; i++) {
        for (let j = 0; j < obj.coordinates[i].length; j++) {
          for (let k = 0; k < source.coordinates.length; k++) {
            breakloop = false;
            if (_isPointInPolygon(obj.coordinates[i][j], source.coordinates[k])) {
              inside = true;
              breakloop = true;
              // Abort as soon as we have found one point inside and one point ouside!
              if (inside && outside) {
                return true;
              }
              break;
            }
          }
          if (!breakloop) {
            outside = true;
            if (inside && outside) {
              return true;
            }
          }
        }
      }
      return false;
    }

    /**
     * Checks if the GeoJSON object intersects the $geoIntersects polygon.
     *
     * @function (arg1, arg2)
     * @private
     * @param {Object}          the GeoJSON object,
     * @param {Object}          the GeoSpatial query,
     * @returns {Boolean}       returns true if the query is successful, false otherwise,
     * @since 0.0.0
     */
    function _intersects(obj, source) {
      switch (obj.type) {
        // Point can't intersect a polygon.
        /* istanbul ignore next */
        case 'Point':
          return false;

        // LineString could intersect a polygon.
        case 'LineString':
          return _interLineString(obj, source);

        // Polygon could intersect a polygon.
        case 'Polygon':
          return _interPolygon(obj, source);

        // MultiPoint can't intersect a polygon.
        /* istanbul ignore next */
        case 'MultiPoint':
          return false;

        // MultiLineString could intersect a polygon.
        /* istanbul ignore next */
        case 'MultiLineString':
          return false;

        // MultiPolygon could intersect a polygon.
        /* istanbul ignore next */
        case 'MultiPolygon':
          return false;

        // ???
        /* istanbul ignore next */
        case 'GeometryCollection':
          return false;

        /* istanbul ignore next */
        default:
          return false;
      }
    }

    /**
     * Checks if the GeoJSON Point matches the condition of distance from the central point.
     *
     * @function (arg1, arg2, arg3, arg4)
     * @private
     * @param {Object}          the GeoJSON Point,
     * @param {Object}          the GeoSpatial $near query,
     * @param {Number}          the minimal distance from the central point in meters,
     * @param {Number}          the maximal distance from the central point in meters,
     * @returns {Boolean}       returns true if the query is successful, false otherwise,
     * @since 0.0.0
     */
    function _isPointNear(obj, source, max, min) {
      // Always true is max and min are not defined!
      if (max === undefined && min === undefined) {
        return true;
      }

      // Always false if max is lower then min!
      if (max < min) {
        return false;
      }

      // Compute the earth distance:
      const d = _getDistanceOnEarth(obj, source);

      // Return true if min <= d <= max (if min or max is undefined, the
      // associated condition is true).
      /* eslint-disable-next-line */
      return (!min || d >= min ? true : false) && (!max || d <= max ? true : false) ? true : false;
    }

    /**
     * Checks if the GeoJSON object matches the $near query.
     *
     * @function (arg1, arg2, arg3, arg4)
     * @private
     * @param {Object}          the GeoJSON object,
     * @param {Object}          the GeoSpatial $near query,
     * @param {Number}          the minimal distance from the central point in meters,
     * @param {Number}          the maximal distance from the central point in meters,
     * @returns {Boolean}       returns true if the query is successful, false otherwise,
     * @since 0.0.0
     */
    function _geoNear(obj, source, max, min) {
      switch (obj.type) {
        case 'Point':
          return _isPointNear(obj, source, max, min);

        default:
          return false;
      }
    }

    /**
     * Checks if the GeoJSON object matches the $geoWithin query.
     *
     * @function (arg1, arg2)
     * @private
     * @param {Object}          the GeoJSON object,
     * @param {Object}          the GeoSpatial $geoWithin query,
     * @returns {Boolean}       returns true if the query is successful, false otherwise,
     * @throws {Object}         throws an error if the GeoSpatial operator isn't recognized,
     * @since 0.0.0
     */
    function _geoWithin(obj, source) {
      const op = _.keys(source)[0]
          ;

      /* istanbul ignore next */
      if (!_.isObject(source)) {
        return false;
      }

      switch (op) {
        case '$geometry':
          return _within(obj, source.$geometry);

        case '$box':
          return _box(obj, source.$box);

        case '$polygon':
          return _polygon(obj, source.$polygon);

        case '$center':
          return _center(obj, source.$center);

        case '$centerSphere':
          return _centerSphere(obj, source.$centerSphere);

        /* istanbul ignore next */
        default:
          throw new Error(
            `Geo._geoWithin: the GeoSpatial $geoWihin operator "${op}" is unknown!`,
          );
      }
    }

    /**
     * Checks if the GeoJSON object matches the $geoIntersects query.
     *
     * @function (arg1, arg2)
     * @private
     * @param {Object}          the GeoJSON object,
     * @param {Object}          the GeoSpatial query,
     * @returns {Boolean}       returns true if the query is successful, false otherwise,
     * @throws {Object}         throws an error if the GeoSpatial operator isn't recognized,
     * @since 0.0.0
     */
    function _geoIntersects(obj, source) {
      /* istanbul ignore next */
      if (!{}.hasOwnProperty.call(source, '$geometry')) {
        return false;
      }

      switch (source.$geometry.type) {
        case 'Polygon':
          return _intersects(obj, source.$geometry);

        /* istanbul ignore next */
        default:
          throw new Error(
            `Geo._geoIntersects: the GeoSpatial $geoIntersects type "${source.$geometry.type}" is not supported!'`,
          );
      }
    }

    /**
     * Checks if the GeoJSON object matches the $near query.
     *
     * @function (arg1, arg2)
     * @private
     * @param {Object}          the GeoJSON object,
     * @param {Object}          the GeoSpatial query,
     * @returns {Boolean}       returns true if the query is successful, false otherwise,
     * @since 0.0.0
     */
    function _near(obj, source) {
      // if (!source.hasOwnProperty(('$geometry')))
      if (!{}.hasOwnProperty.call(source, '$geometry')) {
        return false;
      }

      switch (source.$geometry.type) {
        case 'Point':
          return _geoNear(obj, source.$geometry, source.$maxDistance, source.$minDistance);

        default:
          return false;
      }
    }

    /**
     * Decodes the GeoSpatial query.
     *
     * @function (arg1, arg2)
     * @private
     * @param {Object}          the GeoJSON object,
     * @param {Object}          the GeoSpatial query,
     * @returns {Boolean}       returns true if the query is successful, false otherwise,
     * @throws {Object}         throws an error if the GeoSpatial operator isn't recognized,
     * @since 0.0.0
     */
    function _query(obj, source) {
      let status;

      _.forPropIn(source, (prop) => {
        switch (prop) {
          case '$geoWithin':
            status = _geoWithin(obj, source[prop]);
            break;

          case '$geoIntersects':
            status = _geoIntersects(obj, source[prop]);
            break;

          case '$near':
            status = _near(obj, source[prop]);
            break;

          /* istanbul ignore next */
          case '$nearSphere':
            status = false;
            break;

          /* istanbul ignore next */
          default:
            throw new Error(
              `Geo._query: the Geo Operator "${prop}" is unknown!`,
            );
        }
      });
      return status;
    }


    // -- Public Static Methods ------------------------------------------------

    const Geo = {

      /**
       * Returns the distance between two points on Earth using the law of haversines.
       *
       * @method (arg1, arg2)
       * @public
       * @param {Object}        the destination point,
       * @param {Object}        the source point,
       * @returns {Boolean}     returns the distance between the two points in meters,
       * @since 0.0.0
       */
      lawOfHaversines(obj, source) {
        return _lawOfHaversines(obj, source);
      },

      /**
       * Returns the distance between two points on Earth using the law of cosines.
       *
       * @method (arg1, arg2)
       * @public
       * @param {Object}        the destination point,
       * @param {Object}        the source point,
       * @returns {Boolean}     returns the distance between the two points in meters,
       * @since 0.0.0
       */
      lawOfCosines(obj, source) {
        return _lawOfCosines(obj, source);
      },

      /**
       * Returns the distance between two points on Earth using the Equirectangular projection.
       *
       * @method (arg1, arg2)
       * @public
       * @param {Object}        the destination point,
       * @param {Object}        the source point,
       * @returns {Boolean}     returns the distance between the two points in meters,
       * @since 0.0.0
       */
      equirectangularProjection(obj, source) {
        return _equirectangularProjection(obj, source);
      },

      /**
       * Processes the GeoSpatial query.
       *
       * @function (arg1, arg2)
       * @private
       * @param {Object}        the GeoJSON object,
       * @param {Object}        the GeoSpatial query,
       * @returns {Boolean}     returns true if the query is successful,
       * @since 0.0.1
       */
      query(obj, source) {
        return _query(obj, source);
      },
    };


    // -- Export
    $__TREE.extend($__TREE.src.private.geo, Geo);

    /* eslint-enable one-var, semi-style, no-underscore-dangle */
  }());

  /* index: 10, path: 'src/private/query.js', import: [2, 9] */
  (function() {
    /** ************************************************************************
     *
     * Performs the query.
     *
     * query.js is just a literal object that contains a set of functions.
     * It can't be instantiated.
     *
     * Private Functions:
     *  . _isHavingNotOperator        returns object keys of the not,
     *  . _isHavingANDandOROperators  returns the query array if $and and $or operator,
     *  . _isHavingAndorOrOperator    returns the query array if $and or $or operator,
     *  . _isHavingSpecialOperator    returns special operators or false,
     *  . _isConditionTrue            checks if the document meets the condition,
     *  . _areConditionsTrue          checks if the document meets all the conditions,
     *  . _query                      checks if the document matches the query,
     *  . _isMatch                    checks if the document matches,
     *
     *
     * Public Static Methods:
     *  . isHavingSpecialOperator     returns an object if any special operators,
     *  . isMatch                     checks if the document matches,
     *
     *
     *
     * @namespace    -
     * @dependencies none
     * @exports      -
     * @author       -
     * @since        0.0.0
     * @version      -
     * ********************************************************************** */
    /* - */
    /* eslint-disable one-var, semi-style, no-underscore-dangle */


    // -- Vendor Modules


    // -- Local Modules
    const { _ } = $__TREE.src.lib;
    const Geo = $__TREE.src.private.geo;


    // -- Local Constants


    // -- Local Variables


    // -- Private Functions ----------------------------------------------------


    /**
     * Returns object keys of the not ($ne, $nin) operators if any.
     *
     * @function (arg1)
     * @private
     * @param {Object}          the query object,
     * @returns {Array}         returns the list of objects keys for not operators,
     * @since 0.0.0
     */
    /* eslint-disable dot-notation */
    function _isHavingNotOperator(query) {
      const op  = ['$ne', '$nin', '$not']
          , not = []
          ;

      if (_.contains(_.keys(query), '$or')) {
        const qar = query['$or'];
        for (let i = 0; i < qar.length; i++) {
          _.forPropIn(qar[i], (key) => {
            for (let j = 0; j < op.length; j++) {
              // const re = new RegExp('"\\' + op[j] + '":');
              const re2 = new RegExp(`"\\${op[j]}":`);
              const x = JSON.stringify(qar[i]).match(re2);
              if (x) {
                not.push(key);
              }
            }
          });
        }
      } else {
        _.forPropIn(query, (key) => {
          for (let j = 0; j < op.length; j++) {
            // const re = new RegExp('"\\' + op[j] + '":');
            const re2 = new RegExp(`"\\${op[j]}":`);
            const x = JSON.stringify(query[key]).match(re2);
            if (x) {
              not.push(key);
            }
          }
        });
      }
      return not.length !== 0 ? not : false;
    }
    /* eslint-enable dot-notation */

    /**
     * Returns the query array if $and and $or operator.
     *
     * Nota:
     * It searchs if a query is an $and with an array of $or operators
     * like that:
     *  . { $and : [{ $or: [{...}, {...}] }, { $or: [{...}, {...}] } }
     *
     * @function (arg1)
     * @private
     * @param {Object}          the query object,
     * @returns {Array}         returns the query array or false,
     * @since 0.0.0
     */
    function _isHavingANDandOROperators(query) {
      if (!query.$and || !_.isArray(query.$and) || !query.$and[0] || !query.$and[0].$or) {
        return false;
      }

      let match = true;
      let keys;
      for (let i = 0; i < query.$and.length; i++) {
        keys = Object.keys(query.$and[i]);
        if (keys.length > 1 || !query.$and[i].$or || !_.isArray(query.$and[i].$or)) {
          match = false;
          break;
        }

        // Check that all $or elements are objects:
        for (let j = 0; j < query.$and[i].$or.length; j++) {
          if (!_.isLiteralObject(query.$and[i].$or[j])) {
            match = false;
            break;
          }
        }
        if (!match) break;
      }
      return match ? query.$and : false;
    }

    /**
     * Returns the query array if $and or $or operator.
     *
     * Nota:
     * Must be $and or $or like that:
     *  . { $and: [{ a: { $eq: 1}}, { b: { $eq: 2 }}] }] }
     *  . { or: [{ a: { $eq: 1}}, { b: { $eq: 2 }}] }] }
     *
     * @function (arg1, arg2)
     * @private
     * @param {Object}          the query object,
     * @param {String}          the operator,
     * @returns {Array}         returns the query array or false,
     * @since 0.0.0
     */
    function _isHavingAndorOrOperator(query, op) {
      if (!query[op] || !_.isArray(query[op]) || !query[op][0]) return false;

      // Check that isn't the structure of $and: [{ $or: [{}]}]
      if (query.$and && query.$and[0].$or) return false;

      // Check that all $and or $or elements are objects:
      let match = true;
      for (let i = 0; i < query[op].length; i++) {
        if (!_.isLiteralObject(query[op][i])) {
          match = false;
          break;
        }
      }
      return match ? query[op] : false;
    }

    /**
     * Returns special operators or false.
     *
     * Nota:
     * query must be:
     *  . { $and: [{ $or: [...] }, { $or: [...] }] }
     *  . { $and: [{ a: { $eq: 1}}, { b: { $eq: 2 }}] }] }
     *  . { $or: [{ a: { $eq: 1}}, { b: { $eq: 2 }}] }] }
     *  . { a: { $ne: 2 }, b: { $nin: ['A', 'B'] }, c: { $not: { $eq: 1 }}}
     *
     * @function (arg1)
     * @private
     * @param {Object}          the query object,
     * @returns {Object}        returns the special operators.
     * @since 0.0.0
     */
    function _isHavingSpecialOperator(query) {
      return {
        andor: _isHavingANDandOROperators(query),
        and: _isHavingAndorOrOperator(query, '$and'),
        or: _isHavingAndorOrOperator(query, '$or'),
        not: _isHavingNotOperator(query),
      };
    }

    /**
     * Checks if the document meets the condition.
     *
     * @function (arg1, arg2, arg3)
     * @private
     * @param {String/Number}   the document value,
     * @param {Object}          the condition,
     * @param {String}          the query operator,
     * @returns {Boolean}       returns true if it matches, false otherwise,
     * @throws {Object}         throws an error if the condition operator isn't recognized,
     * @since 0.0.0
     */
    function _isConditionTrue(obj, source, op) {
      switch (op) {
        // Comparison Operators:
        case '$eq':
          return obj === source;

        case '$gt':
          return obj > source;

        case '$gte':
          return obj >= source;

        case '$lt':
          return obj < source;

        case '$lte':
          return obj <= source;

        case '$ne':
          return obj !== source;

        case '$in':
          return _.isArray(obj)
            ? !_.isEmpty(_.share(source, obj))
            : _.contains(source, obj);

        case '$nin':
          return _.isArray(obj)
            ? _.isEmpty(_.share(source, obj))
            : !_.contains(source, obj);

        // Logical Operators:
        case '$not':
          /* eslint-disable-next-line no-use-before-define */
          return !_areConditionsTrue(obj, source);

        // Element Operators:
        case '$exists':
          return source;

          // Evaluation Operators:
          // --

        // Geospatial Operators:
        case '$geoWithin':
          return Geo.query(obj, { $geoWithin: source });

        case '$geoIntersects':
          return Geo.query(obj, { $geoIntersects: source });

        case '$near':
          return Geo.query(obj, { $near: source });

        /* istanbul ignore next */
        case '$nearSphere':
          return Geo.query(obj, { $nearSphere: source });

          // Array Operators:
          // --

          // Bitwise Operators:
          // --

          // Comments Operators:
          // --

        /* istanbul ignore next */
        default:
          throw new Error(
            `Query._isConditionTrue: the operator "${op}" is unknown!`,
          );
      }
    }

    /**
     * Checks if the document meets all the conditions.
     *
     * @function (arg1, arg2, arg3)
     * @private
     * @param {String/Number}   the document value,
     * @param {Object}          the conditions,
     * @returns {Boolean}       returns true if it matches, false otherwise,
     * @since 0.0.0
     */
    /* eslint-disable no-restricted-syntax */
    function _areConditionsTrue(obj, source) {
      let prop;

      // Without an Operator:
      if (!_.isArray(source) && !_.isObject(source)) {
        if (obj === source) {
          return true;
        }
        return false;
      }

      // With an Operator:
      for (prop in source) {
        if (!_isConditionTrue(obj, source[prop], prop)) {
          return false;
        }
      }
      return true;
    }
    /* eslint-enable no-restricted-syntax */

    /**
     * Checks if the document matches the query.
     *
     * The query looks like:
     *   { field: value | condition(s), field: value | condition(s), etc. }
     *
     * Basic query:
     * The basic query is an object with a set of pair of field/conditions.
     * The implicit link between each pair is an AND. If one condition fails,
     * the whole query fails. Thus, as soon as the first field doesn't match
     * the condition, the process stops and return false.
     *
     * Special operators $ne, $nin, $not:
     * With these operators, the query is successful if the field matches the
     * condition or it doesn't exist.
     *
     * Special operator $or:
     * As said, the link between field/conditions is an implicit AND. With the
     * operator $or the implicit AND is replaced by an implicit OR.
     *
     * @function (arg1, arg2, arg3)
     * @private
     * @param {Object}          the document,
     * @param {Object}          the query,
     * @param {Object}          the special operator object,
     * @returns {Boolean}       returns true if the conditions are met,
     * @since 0.0.0
     */
    /* eslint-disable no-shadow, no-restricted-syntax, no-continue, guard-for-in,
      no-else-return */
    function _query(obj, source, op) {
      let level = 0
        , rootKey
        ;

      // Parse the query object recursively and check if the document has the
      // field on which the test will apply or has/hasn't for the not
      // operators.
      function parse(obj, source) {
        let prop;

        for (prop in source) {
          if (level === 0) {
            rootKey = prop;
          }

          // if (!obj[prop]) {
          if (obj[prop] === undefined) {
            if (!op.not || !_.contains(op.not, rootKey)) {
              return false;
            } else if (op.or) {
              return true;
            }
            continue;
          }

          if (_.isObject(source[prop]) && !_.keys(source[prop])[0].match(/^\$/)) {
            level += 1;
            if (!parse(obj[prop], source[prop])) {
              level -= 1;
              if (!op.or) {
                return false;
              }
            } else if (op.or) {
              return true;
            }
          } else if (!_areConditionsTrue(obj[prop], source[prop])) {
            if (!op.or) {
              return false;
            }
          } else if (op.or) {
            return true;
          }
        }
        return !op.or;
      }

      return parse(obj, source);
    }

    /**
     * Checks if the document matches.
     *
     * @method (arg1, arg2, arg3)
     * @public
     * @param {Object}          the document,
     * @param {Object}          the query object,
     * @param {Object}          special operator object,
     * @returns {Boolean}       returns true if the object matches,
     * @since 0.0.0
     */
    function _isMatch(doc, query, sop) {
      if (!sop.andor && !sop.and && !sop.or) {
        return _query(doc, query, sop);
      }

      if (sop.and) {
        // matches if all the conditions match.
        for (let i = 0; i < query.$and.length; i++) {
          if (!_query(doc, query.$and[i], sop)) {
            return false;
          }
        }
        return true;
      }

      if (sop.or) {
        // matches if at least one condition matches.
        for (let i = 0; i < query.$or.length; i++) {
          if (_query(doc, query.$or[i], sop)) {
            return true;
          }
        }
        return false;
      }

      if (sop.andor) {
        // matches if all the $or conditions match.
        const match = [];
        for (let i = 0; i < query.$and.length; i++) {
          for (let j = 0; j < query.$and[i].$or.length; j++) {
            if (_query(doc, query.$and[i].$or[j], sop)) {
              match.push(1);
              break;
            }
          }
        }
        return match.length === query.$and.length;
      }

      /* istanbul ignore next */
      return false;
    }


    // -- Public Static Methods ------------------------------------------------

    const Query = {

      /**
       * Returns an object if any special operators.
       *
       * @method (arg1)
       * @public
       * @param {Object}        the query object,
       * @returns {Array}       returns the list of objects keys for not operators,
       * @since 0.0.0
       */
      isHavingSpecialOperator(query) {
        return _isHavingSpecialOperator(query);
      },

      /**
       * Checks if the document matches.
       *
       * @method (arg1, arg2, arg3)
       * @public
       * @param {Object}        the document,
       * @param {Object}        the query object,
       * @param {Object}        special operator object,
       * @returns {Boolean}     returns true if the object matches, false otherwise,
       * @since 0.0.0
       */
      isMatch(doc, query, sop) {
        return _isMatch(doc, _.normalize(query), sop);
      },
    };


    // -- Export
    $__TREE.extend($__TREE.src.private.query, Query);

    /* eslint-enable one-var, semi-style, no-underscore-dangle */
  }());

  /* index: 11, path: 'src/private/projection.js', import: [2] */
  (function() {
    /** ************************************************************************
     *
     * A set of functions to format the documents returned by toArray.
     *
     * projection.js is just a literal object that contains a set of functions.
     * It can't be instantiated.
     *
     * Private Functions:
     *  . _include                    returns an excerpt of the selected document,
     *  . _exclude                    returns an excerpt of the selected document,
     *
     *
     * Public Static Methods:
     *  . setProjection               sets the projection value,
     *  . isProjectionTypeInclude     returns the type of projection,
     *  . adds                        elements of the document to doc,
     *
     *
     *
     * @namespace    -
     * @dependencies none
     * @exports      -
     * @author       -
     * @since        0.0.0
     * @version      -
     * ********************************************************************** */
    /* - */
    /* eslint-disable one-var, semi-style, no-underscore-dangle */


    // -- Vendor Modules


    // -- Local Modules
    const { _ } = $__TREE.src.lib;


    // -- Local Constants


    // -- Local Variables


    // -- Private Functions ----------------------------------------------------

    /**
     * Returns an excerpt of the selected document based on an include projection.
     *
     * Note:
     * It includes the fields listed in the projection with a value of 1. the
     * unknown fields or the fields with a value other than 1 are ignored.
     *
     * @function (arg1, arg2, arg3)
     * @private
     * @param {Object}          the selected document,
     * @param {Object}          the projection to apply,
     * @param {Object}          the initial value of the document excerpt,
     * @returns {Object}        the excerpt of the selected document,
     * @since 0.0.0
     */
    /* eslint-disable no-param-reassign */
    function _include(obj, source, data) {
      _.forPropIn(source, (prop) => {
        if (obj[prop]) {
          if (_.isObject(source[prop])) {
            data[prop] = {};
            _include(obj[prop], source[prop], data[prop]);
          } else if (source[prop] === 1) {
            if (_.isObject(obj[prop])) {
              data[prop] = _.clone(obj[prop]);
            } else if (obj[prop]) {
              data[prop] = obj[prop];
            }
          }
        }
      });
      return data;
    }
    /* eslint-enable no-param-reassign */

    /**
     * Returns an excerpt of the selected document based on an exclude projection.
     *
     * Note:
     * It excludes the fields listed in the projection with a value of 0. The
     * unspecified fields are kept.
     *
     * @function (arg1, arg2, arg3)
     * @private
     * @param {Object}          the selected document,
     * @param {Object}          the projection to apply,
     * @param {Object}          the initial value of the document excerpt,
     * @returns {Object}        the excerpt of the selected document,
     * @since 0.0.1
     */
    /* eslint-disable no-param-reassign */
    function _exclude(obj, source, data) {
      _.forPropIn(obj, (prop) => {
        if (source[prop] !== undefined) {
          if (_.isObject(source[prop])) {
            data[prop] = {};
            _exclude(obj[prop], source[prop], data[prop]);
          }
        } else if (_.isObject(obj[prop])) {
          data[prop] = _.clone(obj[prop]);
        } else {
          data[prop] = obj[prop];
        }
      });
      return data;
    }
    /* eslint-enable no-param-reassign */


    // -- Public Static Methods ------------------------------------------------

    const Proj = {

      /**
       * Sets the projection value.
       *
       * Note:
       * If it is an include projection, the _id field is explicitely defined
       * in the projection.
       *
       * @method (arg1, arg2)
       * @public
       * @param {Object}        the projection,
       * @param {Boolean}       the current type,
       * @returns {Object}      the updated projection,
       * @since 0.0.0
       */
      setProjection(projection, type) {
        if (!type) {
          return projection;
        }

        if (projection._id !== undefined) {
          return projection;
        }
        return _.extend({ _id: 1 }, projection);
      },

      /**
       * Returns the type of projection.
       *
       * Note:
       * If one 'field' is equal to 1, it's an include projection. It means that
       * only the fields defined in the projection, and equal to 1, are included
       * in the output.
       *
       * By default, '_id' is included except if it is explicitely defined to be
       * excluded in the projection (_id: 0).
       *
       * If all the fields in the projection are equal to 0, it's an exclude
       * projection. It means that only these fields are removed from the output.
       *
       * @method (arg1)
       * @public
       * @param {Object}        the projection,
       * @returns {Boolean}     true if it is an include projection,
       * @since 0.0.0
       */
      /* eslint-disable no-restricted-syntax */
      isProjectionTypeInclude(projection) {
        let prop;
        for (prop in projection) {
          if (_.isObject(projection[prop])) {
            if (this.isProjectionTypeInclude(projection[prop])) {
              return true;
            }
          } else if (projection[prop]) {
            return true;
          }
        }
        return false;
      },
      /* eslint-enable no-restricted-syntax */

      /**
       * Adds elements of the document to doc in accordance with projection.
       *
       * Note: this function mutates the argument `doc`.
       *
       * @method (arg1, arg2, arg3)
       * @public
       * @param {Object}        the current list of documents already selected,
       * @param {Object}        the current document,
       * @param {Object}        the projection object,
       * @returns {}            -,
       * @since 0.0.0
       */
      add(doc, data, projection) {
        // If projection is empty means no filtering of the output!
        if (_.isEmpty(projection.value)) {
          doc.push(_.clone(data));
        } else if (projection.type) {
          doc.push(_include(data, projection.value, {}));
        } else {
          doc.push(_exclude(data, projection.value, {}));
        }
      },
    };


    // -- Export
    $__TREE.extend($__TREE.src.private.projection, Proj);

    /* eslint-enable one-var, semi-style, no-underscore-dangle */
  }());


  // Returns the library name:
  return $__TREE.src.picodb;
}));
