/*! ****************************************************************************
 * PicoDB v1.0.5
 *
 * A tiny in-memory database (MongoDB like) that stores JSON documents.
 * (you can download it from npm or github repositories)
 * Copyright (c) 2023 Mobilabs <contact@mobilabs.fr> (http://www.mobilabs.fr).
 * Released under the MIT license. You may obtain a copy of the License
 * at: http://www.opensource.org/licenses/mit-license.php).
 * Built from ES6Kadoo v1.0.10.
 * ************************************************************************** */
/*! Generated by Kadoo v1.0.7 */
!function(e,t){"use strict";"function"==typeof define&&define.amd?define([""],t):"object"==typeof exports?module.exports=t(e):e.PicoDB=t(e)}(this,(e=>{"use strict";let t={src:{picodb:{},lib:{_:{},plugin:{}},private:{count:{},delete:{},find:{},insert:{},update:{},geo:{},query:{},projection:{}}},extend:function(e,t){for(var n=Object.keys(t),r=0;r<n.length;r++)e[n[r]]=t[n[r]]}};return function(){const{_:n}=t.src.lib,r=t.src.private.count,i=t.src.private.delete,s=t.src.private.find,o=t.src.private.insert,l=t.src.private.update,c=t.src.lib.plugin,a=t.src.private.geo;let u;const f=function(){const e=Object.create(u);e._library={name:"PicoDB",version:"1.0.5"},e._cursor=s.initCursor(),e._db=o.schema();const t=c.get("messenger");return e._mess=t?t():null,e};f.NAME="PicoDB",f.VERSION="1.0.5";const h=e.PicoDB;f._setTestMode=function(){return[a,c,n]},f.noConflict=function(){return e.PicoDB=h,this},f.plugin=function(e){return c.plugin(e)},u={whoami(){return this._library},insertOne(...e){return o.insert(this._db,this._mess,!1,...e)},insertMany(...e){return o.insert(this._db,this._mess,!0,...e)},find(...e){return s.find(this._cursor,...e),this},toArray(e){return s.toArray(this._db,this._cursor,e)},count(...e){return r.count(this._db,...e)},updateOne(...e){return l.update(this._db,this._mess,!1,...e)},updateMany(...e){return l.update(this._db,this._mess,!0,...e)},deleteOne(...e){return i.delete(this._db,this._mess,!1,...e)},deleteMany(...e){return i.delete(this._db,this._mess,!0,...e)},addEventListener(e,t){return this._mess?(this._mess.subscribe(e,t),this):(console.log("warning: the plugin @mobilabs/messenger isn't installed!"),this)},addOneTimeEventListener(e,t){return this._mess?(this._mess.subscribeOnce(e,t),this):(console.log("warning: the plugin @mobilabs/messenger isn't installed!"),this)},removeEventListener(e,t){return this._mess&&this._mess.unsubscribe(e,t),this},on(e,t){return this.addEventListener(e,t)},one(e,t){return this.addOneTimeEventListener(e,t)},off(e,t){return this.removeEventListener(e,t)}},t.src.picodb=f}(),function(){function e(t){const n={};return Object.keys(t).forEach((r=>{if(r.includes(".")){const i=r.split(".");let s=n;for(let n=0;n<i.length;n++)n<i.length-1?(s[i[n]]={},s=s[i[n]]):"[object Object]"===Object.prototype.toString.call(t[r])?s[i[n]]=e(t[r]):s[i[n]]=t[r]}else"[object Object]"===Object.prototype.toString.call(t[r])?n[r]=e(t[r]):n[r]=t[r]})),n}const n={isUndefined:e=>void 0===e,isNull:e=>null===e,isBoolean:e=>!0===e||!1===e||"[object Boolean]"===Object.prototype.toString.call(e),isString:e=>"[object String]"===Object.prototype.toString.call(e),isNumber:e=>"[object Number]"===Object.prototype.toString.call(e),isNaN(e){return this.isNumber(e)&&e!==+e},isOdd(e){const t=e%2;return e===parseFloat(e)?!!t:void 0},isObject(e){const t=typeof e;return("function"===t||"object"===t)&&!!e},isLiteralObject:e=>"[object Object]"===Object.prototype.toString.call(e),isFunction:e=>"[object Function]"===Object.prototype.toString.call(e),isArray:e=>"[object Array]"===Object.prototype.toString.call(e),isEmpty(e){let t;if(null===e)return!0;if(this.isArray(e)||this.isString(e))return 0===e.length;for(t in e)if(e.hasOwnProperty(t))return!1;return!0},clone(e){const t=this.isArray(e)?[]:{};let n;if(this.isObject(e)){for(n in e)this.isArray(e[n])?t[n]=this.clone(e[n]):this.isObject(e[n])?t[n]=this.extend(e[n]):t[n]=e[n];return t}},extend(e){let t,n;if(!this.isObject(e))return e;for(let r=1;r<arguments.length;r++)for(n in t=arguments[r],t)this.isLiteralObject(arguments[r][n])?(e[n]=void 0!==e[n]?e[n]:{},this.extend(e[n],arguments[r][n])):hasOwnProperty.call(t,n)&&(e[n]=this.isArray(t[n])?this.clone(t[n]):t[n]);return e},keys:e=>Object.keys(e),forPropIn(e,t){this.keys(e).forEach((n=>{({}).hasOwnProperty.call(e,n)&&t(n)}))},contains:(e,t)=>-1!==e.indexOf(t),share(e){const t=[];let n,r,i;for(r=0;r<e.length;r++)if(n=e[r],!this.contains(t,n)){for(i=1;i<arguments.length&&this.contains(arguments[i],n);i++);i===arguments.length&&t.push(n)}return t},token:()=>Math.random().toString(36).substr(2),normalize:t=>e(t)};t.extend(t.src.lib._,n)}(),function(){const{_:e}=t.src.lib,n=t.src.private.query;const r={count(t,...r){const[i,s,o]=function(...t){switch(t.length){case 1:return e.isLiteralObject(t[0])?[t[0],{},null]:(e.isFunction(t[0]),[null,{},t[0]]);case 2:return e.isLiteralObject(t[0])?e.isLiteralObject(t[1])?[t[0],t[1],null]:e.isFunction(t[1])?[t[0],{},t[1]]:[t[0],{},null]:e.isFunction(t[1])?[null,{},t[1]]:[null,{},null];case 3:return e.isLiteralObject(t[0])?e.isLiteralObject(t[1])?e.isFunction(t[2])?[t[0],t[1],t[2]]:[t[0],t[1],null]:e.isFunction(t[2])?[t[0],{},t[2]]:[t[0],{},null]:(e.isFunction(t[2]),[null,{},t[2]]);default:return[null,{},null]}}(...r);return new Promise(((e,r)=>{!function(e,t,r,i){if(!t)return void i(null,0);const s=n.isHavingSpecialOperator(t);let o=0;for(let r=0;r<e.data.length;r++)n.isMatch(e.data[r],t,s)&&(o+=1);i(null,o)}(t,i,0,((t,n)=>{t?(r(t),o&&o(t)):(e(n),o&&o(null,n))}))}))}};t.extend(t.src.private.count,r)}(),function(){const{_:e}=t.src.lib,n=t.src.private.query;const r={delete(t,r,i,...s){const[o,l,c]=function(...t){switch(t.length){case 1:return e.isLiteralObject(t[0])?[t[0],{},null]:e.isFunction(t[0])?[null,{},t[0]]:[null,{},null];case 2:return e.isLiteralObject(t[0])?e.isLiteralObject(t[1])?[t[0],t[1],null]:e.isFunction(t[1])?[t[0],{},t[1]]:[t[0],{},null]:e.isFunction(t[1])?[null,null,t[1]]:[null,null,null];case 3:return e.isLiteralObject(t[0])?e.isLiteralObject(t[1])?e.isFunction(t[2])?[t[0],t[1],t[2]]:[t[0],t[1],null]:e.isFunction(t[2])?[t[0],{},t[2]]:[t[0],{},null]:e.isFunction(t[2])?[null,null,t[2]]:[null,null,null];default:return[null,null,null]}}(...s);return new Promise(((e,s)=>{!function(e,t,r,i,s,o){if(!i)return void o(null,0);let l,c,a=[];const u=n.isHavingSpecialOperator(i);a=[],l=0,c=e.data.length;for(let t=0;t<c&&(!n.isMatch(e.data[t],i,u)||(a.push(e.data.splice(t,1)[0]),l+=1,t-=1,c-=1,r));t++);t&&(t.publish("delete",a),t.publish("change",a)),o(null,l)}(t,r,i,o,0,((t,n)=>{t?(s(t),c&&c(t)):(e(n),c&&c(null,n))}))}))}};t.extend(t.src.private.delete,r)}(),function(){const{_:e}=t.src.lib,n=t.src.private.projection,r=t.src.private.query;const i={initCursor:()=>({query:{},projection:{type:null,value:null}}),find(t,...r){const[i,s]=function(...t){return[e.isLiteralObject(t[0])?t[0]:{},e.isLiteralObject(t[1])?t[1]:{}]}(...r);return function(e,t,r){e.query=t,e.projection.type=n.isProjectionTypeInclude(r),e.projection.value=n.setProjection(r,e.projection.type)}(t,i,s),this},toArray(t,i,s){const o=e.isFunction(s)?s:null;return new Promise(((e,s)=>{!function(e,t,i){if(!t.query)return void i("This query isn't a valid Cursor query object");const s=r.isHavingSpecialOperator(t.query),o=[];for(let i=0;i<e.data.length;i++)r.isMatch(e.data[i],t.query,s)&&n.add(o,e.data[i],t.projection);i(null,o)}(t,i,((t,n)=>{t?(s(t),o&&o(t)):(e(n),o&&o(null,n))}))}))}};t.extend(t.src.private.find,i)}(),function(){const{_:e}=t.src.lib;function n(e,t){let n=!0;for(let r=0;r<e.data.length;r++)if(e.data[r]._id===t){n=!1;break}return n}function r(t,r,i,s,o){let l=[];e.isLiteralObject(i)?l.push(i):l=i;const c=[];for(let r=0;r<l.length;r++)if(e.isLiteralObject(l[r]))if(l[r]._id){if(n(t,l[r]._id)&&(t.data.push(e.extend({},l[r])),c.push(e.extend({},l[r])),!s.many))break}else{const n=e.token();if(t.data.push(e.extend({_id:n},l[r])),c.push(e.extend({_id:n},l[r])),!s.many)break}r&&(r.publish("change",c),r.publish("insert",c)),o(null,c)}const i={schema:()=>({data:[]}),insert(t,n,i,...s){const[o,l,c]=function(...t){switch(t.length){case 1:return e.isArray(t[0])||e.isLiteralObject(t[0])?[t[0],{},null]:e.isFunction(t[0])?[[],{},t[0]]:[[],{},null];case 2:return e.isArray(t[0])||e.isLiteralObject(t[0])?e.isLiteralObject(t[1])?[t[0],t[1],null]:e.isFunction(t[1])?[t[0],{},t[1]]:[t[0],{},null]:e.isFunction(t[1])?[[],{},t[1]]:[[],{},null];case 3:return e.isArray(t[0])||e.isLiteralObject(t[0])?e.isLiteralObject(t[1])?e.isFunction(t[2])?[t[0],t[1],t[2]]:[t[0],t[1],null]:e.isFunction(t[2])?[t[0],{},t[2]]:[t[0],{},null]:e.isFunction(t[2])?[[],{},t[2]]:[[],{},null];default:return[[],{},null]}}(...s);return new Promise(((s,a)=>{!function(t,n,i,s,o,l){o.many=i,i&&e.isArray(s)?r(t,n,s,o,l):i||!e.isArray(s)&&!e.isLiteralObject(s)?l(null,[]):r(t,n,s,o,l)}(t,n,i,o,l,((e,t)=>{e?(a(e),c&&c(e)):(s(t),c&&c(null,t))}))}))}};t.extend(t.src.private.insert,i)}(),function(){const{_:e}=t.src.lib,n=t.src.private.query;function r(t,n){let i,s,o,l,c,a,u;for(i in n)if(e.isObject(n[i])&&!e.isArray(t[i]))t[i]&&r(t[i],n[i]);else if(hasOwnProperty.call(n,i)){if(!t[i]||!e.isArray(t[i]))continue;if("boolean"==typeof n[i]||"number"==typeof n[i]||"string"==typeof n[i]){l=t[i].indexOf(n[i]),l>-1&&t[i].splice(l,1);continue}if(e.isObject(n[i])&&!e.keys(n[i])[0].match(/^\$/)){for(u=t[i].length-1;u>=0&&e.isObject(t[i][u]);u--){for(s in o=!0,n[i])if(t[i][u][s]!==n[i][s]){o=!1;break}o&&t[i].splice(u,1)}continue}if(e.isObject(n[i])){switch([c]=e.keys(n[i]),c){case"$eq":l=t[i].indexOf(n[i].$eq),l>-1&&t[i].splice(l,1);break;case"$gt":for(u=t[i].length-1;u>=0;u--)t[i][u]>n[i].$gt&&t[i].splice(u,1);break;case"$gte":for(u=t[i].length-1;u>=0;u--)t[i][u]>=n[i].$gte&&t[i].splice(u,1);break;case"$lt":for(u=t[i].length-1;u>=0;u--)t[i][u]<n[i].$lt&&t[i].splice(u,1);break;case"$lte":for(u=t[i].length-1;u>=0;u--)t[i][u]<=n[i].$lte&&t[i].splice(u,1);break;case"$ne":for(u=t[i].length-1;u>=0;u--)t[i][u]!==n[i].$ne&&t[i].splice(u,1);break;case"$in":if(!e.isArray(n[i].$in))break;for(u=0;u<n[i].$in.length;u++)l=t[i].indexOf(n[i].$in[u]),l>-1&&t[i].splice(l,1);break;case"$nin":if(!e.isArray(n[i].$nin))break;for(a=[],u=0;u<n[i].$nin.length;u++)l=t[i].indexOf(n[i].$nin[u]),l>-1&&a.push(n[i].$nin[u]);t[i]=e.clone(a);break;default:throw new Error(`Update._pull: the operator "${c}" is not supported!`)}continue}}return t}function i(t,n){let r,s,o,l,c;for(r in n)if({}.hasOwnProperty.call(n,r))if(s=e.keys(n[r]),e.isArray(n[r])||!e.isObject(n[r])||s[0].match(/^\$/)){if(hasOwnProperty.call(n,r)){if(t[r]||(t[r]=[]),"boolean"==typeof n[r]||"number"==typeof n[r]||"string"==typeof n[r]){t[r].push(n[r]);continue}if(e.isArray(n[r])){t[r].push(e.clone(n[r]));continue}if(e.isObject(n[r])&&e.isArray(n[r].$each)){for(o=n[r].$position,(void 0===o||"number"!=typeof o||o<0)&&(o=t[r].length),l=n[r].$slice,void 0!==l&&"number"==typeof o||(l=null),c=n[r].$each.length-1;c>=0;c--)t[r].splice(o,0,n[r].$each[c]);l>0?t[r].splice(l,t[r].length-l):0===l?t[r].length=0:l<0&&t[r].splice(0,t[r].length+l)}}}else t[r]||(t[r]={}),i(t[r],n[r]);return t}function s(t,n,r){let i,o,l;for(i in n)if(!e.isArray(n[i])&&e.isObject(n[i])){if(!(t[i]||"$rename"!==r&&"$unset"!==r&&"$pop"!==r))break;t[i]||(t[i]={}),s(t[i],n[i],r)}else if(hasOwnProperty.call(n,i))switch(r){case"$inc":"number"==typeof t[i]?t[i]+=n[i]:t[i]=n[i];break;case"$mul":"number"==typeof t[i]?t[i]*=n[i]:t[i]=0;break;case"$rename":t[i]&&(t[n[i]]=t[i],delete t[i]);break;case"$set":e.isArray(n[i])?t[i]=e.clone(n[i]):t[i]=n[i];break;case"$unset":t[i]&&delete t[i];break;case"$min":(!t[i]||"number"==typeof t[i]&&n[i]<t[i])&&(t[i]=n[i]);break;case"$max":(!t[i]||"number"==typeof t[i]&&n[i]>t[i])&&(t[i]=n[i]);break;case"$pop":e.isArray(t[i])&&(1===n[i]?t[i].pop():-1===n[i]&&t[i].shift());break;case"$pullAll":if(e.isArray(t[i])&&e.isArray(n[i]))for(o=0;o<n[i].length;o++)for(l=t[i].length-1;l>=0;l--)t[i][l]===n[i][o]&&t[i].splice(l,1);break;default:throw new Error(`Update._apply: the operator "${r}" is unknown!`)}return t}function o(t,n){let r,i;for(r in n)({}).hasOwnProperty.call(n,r)&&([i]=e.keys(n[r]),e.isObject(n[r])&&"$type"!==i?(t[r]||(t[r]={}),o(t[r],n[r])):hasOwnProperty.call(n,r)&&("timestamp"===n[r][i]?t[r]=Date.now():t[r]=(new Date).toISOString()));return t}function l(t,n){const l=e.keys(n);if(!l[0].match(/^\$/))return function(t,n){const r=e.keys(t);for(let e=0;e<r.length;e++)"_id"!==r[e]&&delete t[r[e]];return e.extend(t,n)}(t,n);switch(l[0]){case"$inc":return s(t,n.$inc,"$inc");case"$mul":return s(t,n.$mul,"$mul");case"$rename":return s(t,n.$rename,"$rename");case"$set":return s(t,n.$set,"$set");case"$unset":return s(t,n.$unset,"$unset");case"$min":return s(t,n.$min,"$min");case"$max":return s(t,n.$max,"$max");case"$currentDate":return o(t,n.$currentDate);case"$pop":return s(t,n.$pop,"$pop");case"$pullAll":return s(t,n.$pullAll,"$pullAll");case"$pull":return r(t,n.$pull);case"$push":return i(t,n.$push);default:throw new Error(`The Update Operator "${l[0]}" isn't supported!`)}}const c={update(t,r,i,...s){const[o,c,a,u]=function(...t){switch(t.length){case 1:return e.isFunction(t[0])?[null,null,{},t[0]]:[null,null,{},null];case 2:return e.isLiteralObject(t[0])&&e.isLiteralObject(t[1])?[t[0],t[1],{},null]:e.isFunction(t[1])?[null,null,{},t[1]]:[null,null,{},null];case 3:return e.isLiteralObject(t[0])&&e.isLiteralObject(t[1])?e.isLiteralObject(t[2])?[t[0],t[1],t[2],null]:e.isFunction(t[2])?[t[0],t[1],{},t[2]]:[t[0],t[1],{},null]:e.isFunction(t[2])?[null,null,{},t[2]]:[null,null,{},null];case 4:return e.isLiteralObject(t[0])&&e.isLiteralObject(t[1])?e.isLiteralObject(t[2])?e.isFunction(t[3])?[t[0],t[1],t[2],t[3]]:[t[0],t[1],t[2],null]:e.isFunction(t[3])?[t[0],t[1],{},t[3]]:[t[0],t[1],{},null]:e.isFunction(t[3])?[null,null,{},t[3]]:[null,null,{},null];default:return[null,null,{},null]}}(...s);return new Promise(((s,a)=>{!function(t,r,i,s,o,c,a){if(!s||!o)return void a(null,[]);const u=n.isHavingSpecialOperator(s),f=[];for(let r=0;r<t.data.length&&(!n.isMatch(t.data[r],s,u)||(l(t.data[r],o),f.push(e.extend({},t.data[r])),i));r++);r&&(r.publish("update",f),r.publish("change",f)),a(null,f)}(t,r,i,o,c,0,((e,t)=>{e?(a(e),u&&u(e)):(s(t),u&&u(null,t))}))}))}};t.extend(t.src.private.update,c)}(),function(){const{_:e}=t.src.lib;const n={_db:{messenger:null},plugin(t){return function(t,n){return!(!e.isLiteralObject(n)||!n.messenger||"Messenger"!==n.messenger.NAME||(t.messenger=n.messenger,0))}(this._db,t)},get(t){return e.isString(t)&&this._db[t]?this._db[t]:null}};t.extend(t.src.lib.plugin,n)}(),function(){const{_:e}=t.src.lib;function n(e,t){const n=t.coordinates[0],r=(e.coordinates[0]-n)*(Math.PI/180),i=t.coordinates[1]*(Math.PI/180),s=e.coordinates[1]*(Math.PI/180);return 6371e3*Math.acos(Math.sin(i)*Math.sin(s)+Math.cos(i)*Math.cos(s)*Math.cos(r))}function r(e,t){let n,r=0;for(let i=0;i<t.length-1;i++)(t[i][1]<=e[1]&&t[i+1][1]>e[1]||t[i][1]>e[1]&&t[i+1][1]<=e[1])&&(n=(e[1]-t[i][1])/(t[i+1][1]-t[i][1]),e[0]<t[i][0]+n*(t[i+1][0]-t[i][0])&&(r+=1));return r%2!=0}function i(e,t){let n,i;switch(t.type){case"MultiPolygon":for(let s=0;s<e.length;s++)for(let o=0;o<e[s].length;o++){for(let l=0;l<t.coordinates.length;l++){for(n=!1,i=0;i<t.coordinates[l].length;i++)if(r(e[s][o],t.coordinates[l][i])){n=!0;break}if(n)break}if(!n)return!1}return!0;case"Polygon":for(let i=0;i<e.length;i++)for(let s=0;s<e[i].length;s++){n=!1;for(let o=0;o<t.coordinates.length;o++)if(r(e[i][s],t.coordinates[o])){n=!0;break}if(!n)return!1}return!0;default:throw new Error(`Geo._within: the GeoSpatial $geoWihin operator with a $geometry.type "${t.type}" is unknown!`)}}function s(e){switch(e.type){case"Point":return[[e.coordinates]];case"LineString":case"MultiPoint":return[e.coordinates];case"Polygon":case"MultiLineString":return e.coordinates;default:throw new Error(`Geo._toPolygonCoordinates: the GeoJSON type "${e.type}" is not supported!`)}}function o(e,t){switch(e.type){case"Point":case"MultiPoint":case"MultiLineString":case"MultiPolygon":case"GeometryCollection":default:return!1;case"LineString":return function(e,t){let n,i,s;for(let o=0;o<e.coordinates.length;o++){for(let l=0;l<t.coordinates.length;l++)if(s=!1,r(e.coordinates[o],t.coordinates[l])){if(n=!0,s=!0,n&&i)return!0;break}if(!s&&(i=!0,n&&i))return!0}return!1}(e,t);case"Polygon":return function(e,t){let n,i,s;for(let o=0;o<e.coordinates.length;o++)for(let l=0;l<e.coordinates[o].length;l++){for(let c=0;c<t.coordinates.length;c++)if(s=!1,r(e.coordinates[o][l],t.coordinates[c])){if(n=!0,s=!0,n&&i)return!0;break}if(!s&&(i=!0,n&&i))return!0}return!1}(e,t)}}function l(e,t,r,i){if(void 0===r&&void 0===i)return!0;if(r<i)return!1;const s=function(e,t){return n(e,t)}(e,t);return(!i||s>=i)&&(!r||s<=r)}function c(t,n){const r=e.keys(n)[0];if(!e.isObject(n))return!1;switch(r){case"$geometry":return function(e,t){switch(e.type){case"Point":case"LineString":case"Polygon":case"MultiPoint":case"MultiLineString":return i(s(e),t);default:return!1}}(t,n.$geometry);case"$box":return function(e,t){const n={type:"Polygon",coordinates:[[[t[0][0],t[0][1]],[t[1][0],t[0][1]],[t[1][0],t[1][1]],[t[0][0],t[1][1]]]]};return i(s(e),n)}(t,n.$box);case"$polygon":return function(e,t){const n={type:"Polygon",coordinates:[t,[t[0][0],t[0][1]]]};return i(s(e),n)}(t,n.$polygon);case"$center":return function(e,t){return Math.sqrt(Math.pow(t[0][0]-e.coordinates[0],2)+Math.pow(t[0][1]-e.coordinates[1],2))<t[1]}(t,n.$center);case"$centerSphere":return function(e,t){return Math.sqrt(Math.pow(t[0][0]-e.coordinates[0],2)+Math.pow(t[0][1]-e.coordinates[1],2))<t[1]/Math.PI*180}(t,n.$centerSphere);default:throw new Error(`Geo._geoWithin: the GeoSpatial $geoWihin operator "${r}" is unknown!`)}}function a(e,t){return!!{}.hasOwnProperty.call(t,"$geometry")&&("Point"===t.$geometry.type&&function(e,t,n,r){return"Point"===e.type&&l(e,t,n,r)}(e,t.$geometry,t.$maxDistance,t.$minDistance))}function u(t,n){let r;return e.forPropIn(n,(e=>{switch(e){case"$geoWithin":r=c(t,n[e]);break;case"$geoIntersects":r=function(e,t){if(!{}.hasOwnProperty.call(t,"$geometry"))return!1;if("Polygon"===t.$geometry.type)return o(e,t.$geometry);throw new Error(`Geo._geoIntersects: the GeoSpatial $geoIntersects type "${t.$geometry.type}" is not supported!'`)}(t,n[e]);break;case"$near":r=a(t,n[e]);break;case"$nearSphere":r=!1;break;default:throw new Error(`Geo._query: the Geo Operator "${e}" is unknown!`)}})),r}const f={lawOfHaversines:(e,t)=>function(e,t){const n=t.coordinates[0],r=(e.coordinates[0]-n)*(Math.PI/180),i=t.coordinates[1]*(Math.PI/180),s=e.coordinates[1]*(Math.PI/180),o=s-i,l=Math.sin(o/2)*Math.sin(o/2)+Math.cos(i)*Math.cos(s)*Math.sin(r/2)*Math.sin(r/2);return 2*Math.atan2(Math.sqrt(l),Math.sqrt(1-l))*6371e3}(e,t),lawOfCosines:(e,t)=>n(e,t),equirectangularProjection:(e,t)=>function(e,t){const n=t.coordinates[0]*(Math.PI/180),r=e.coordinates[0]*(Math.PI/180),i=t.coordinates[1]*(Math.PI/180),s=e.coordinates[1]*(Math.PI/180),o=(r-n)*Math.cos((i+s)/2),l=s-i;return 6371e3*Math.sqrt(o*o+l*l)}(e,t),query:(e,t)=>u(e,t)};t.extend(t.src.private.geo,f)}(),function(){const{_:e}=t.src.lib,n=t.src.private.geo;function r(t){const n=["$ne","$nin","$not"],r=[];if(e.contains(e.keys(t),"$or")){const i=t.$or;for(let t=0;t<i.length;t++)e.forPropIn(i[t],(e=>{for(let s=0;s<n.length;s++){const o=new RegExp(`"\\${n[s]}":`);JSON.stringify(i[t]).match(o)&&r.push(e)}}))}else e.forPropIn(t,(e=>{for(let i=0;i<n.length;i++){const s=new RegExp(`"\\${n[i]}":`);JSON.stringify(t[e]).match(s)&&r.push(e)}}));return 0!==r.length&&r}function i(t){if(!(t.$and&&e.isArray(t.$and)&&t.$and[0]&&t.$and[0].$or))return!1;let n,r=!0;for(let i=0;i<t.$and.length;i++){if(n=Object.keys(t.$and[i]),n.length>1||!t.$and[i].$or||!e.isArray(t.$and[i].$or)){r=!1;break}for(let n=0;n<t.$and[i].$or.length;n++)if(!e.isLiteralObject(t.$and[i].$or[n])){r=!1;break}if(!r)break}return!!r&&t.$and}function s(t,n){if(!t[n]||!e.isArray(t[n])||!t[n][0])return!1;if(t.$and&&t.$and[0].$or)return!1;let r=!0;for(let i=0;i<t[n].length;i++)if(!e.isLiteralObject(t[n][i])){r=!1;break}return!!r&&t[n]}function o(t,r,i){switch(i){case"$eq":return t===r;case"$gt":return t>r;case"$gte":return t>=r;case"$lt":return t<r;case"$lte":return t<=r;case"$ne":return t!==r;case"$in":return e.isArray(t)?!e.isEmpty(e.share(r,t)):e.contains(r,t);case"$nin":return e.isArray(t)?e.isEmpty(e.share(r,t)):!e.contains(r,t);case"$not":return!l(t,r);case"$exists":return r;case"$geoWithin":return n.query(t,{$geoWithin:r});case"$geoIntersects":return n.query(t,{$geoIntersects:r});case"$near":return n.query(t,{$near:r});case"$nearSphere":return n.query(t,{$nearSphere:r});default:throw new Error(`Query._isConditionTrue: the operator "${i}" is unknown!`)}}function l(t,n){let r;if(!e.isArray(n)&&!e.isObject(n))return t===n;for(r in n)if(!o(t,n[r],r))return!1;return!0}function c(t,n,r){let i,s=0;return function t(n,o){let c;for(c in o)if(0===s&&(i=c),void 0!==n[c]){if(e.isObject(o[c])&&!e.keys(o[c])[0].match(/^\$/)){if(s+=1,t(n[c],o[c])){if(r.or)return!0}else if(s-=1,!r.or)return!1}else if(l(n[c],o[c])){if(r.or)return!0}else if(!r.or)return!1}else{if(!r.not||!e.contains(r.not,i))return!1;if(r.or)return!0}return!r.or}(t,n)}const a={isHavingSpecialOperator:e=>function(e){return{andor:i(e),and:s(e,"$and"),or:s(e,"$or"),not:r(e)}}(e),isMatch:(t,n,r)=>function(e,t,n){if(!n.andor&&!n.and&&!n.or)return c(e,t,n);if(n.and){for(let r=0;r<t.$and.length;r++)if(!c(e,t.$and[r],n))return!1;return!0}if(n.or){for(let r=0;r<t.$or.length;r++)if(c(e,t.$or[r],n))return!0;return!1}if(n.andor){const r=[];for(let i=0;i<t.$and.length;i++)for(let s=0;s<t.$and[i].$or.length;s++)if(c(e,t.$and[i].$or[s],n)){r.push(1);break}return r.length===t.$and.length}return!1}(t,e.normalize(n),r)};t.extend(t.src.private.query,a)}(),function(){const{_:e}=t.src.lib;function n(t,r,i){return e.forPropIn(r,(s=>{t[s]&&(e.isObject(r[s])?(i[s]={},n(t[s],r[s],i[s])):1===r[s]&&(e.isObject(t[s])?i[s]=e.clone(t[s]):t[s]&&(i[s]=t[s])))})),i}function r(t,n,i){return e.forPropIn(t,(s=>{void 0!==n[s]?e.isObject(n[s])&&(i[s]={},r(t[s],n[s],i[s])):e.isObject(t[s])?i[s]=e.clone(t[s]):i[s]=t[s]})),i}const i={setProjection:(t,n)=>n?void 0!==t._id?t:e.extend({_id:1},t):t,isProjectionTypeInclude(t){let n;for(n in t)if(e.isObject(t[n])){if(this.isProjectionTypeInclude(t[n]))return!0}else if(t[n])return!0;return!1},add(t,i,s){e.isEmpty(s.value)?t.push(e.clone(i)):s.type?t.push(n(i,s.value,{})):t.push(r(i,s.value,{}))}};t.extend(t.src.private.projection,i)}(),t.src.picodb}));